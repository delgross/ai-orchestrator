# Nexus Pattern (The Regulator)

**Nexus** is the single gatekeeper for all interactions in the system. It enforces the "Regulator" pattern, ensuring that no user input reaches the Agent Engine without passing through a control layer, and no output reaches the user without traversing the event stream.

**Source**: `ai/agent_runner/nexus.py`

---

## 1. Trigger Registry

Nexus evaluates input against a registry of blocking/non-blocking triggers *before* engaging the LLM.

| Trigger Name | Action Type | Condition (Regex/match) | Output / Behavior |
| :--- | :--- | :--- | :--- |
| **System Prompt** | `diagnostic` | "show me the prompt" | Returns raw system prompt text. |
| **Help** | `diagnostic` | "help" | Returns list of available commands. |
| **Restart** | `diagnostic` | "restart system" | Initiates `tool_restart_agent`. |
| **Emoji Layer** | `ui_layer` | "emoji", "enable_emoji" | Emits `{"type": "layer_update"}` to frontend. |
| **UI Control** | `control_ui` | "clear chat" | Emits `{"type": "control_ui"}`. |

---

## 2. Dispatch Logic Table

| Step | Component | Logic | Async Behavior |
| :--- | :--- | :--- | :--- |
| **1** | **System Queue** | Check `state.system_event_queue` for high-priority alerts. | Yields `system_status` events instantly. |
| **2** | **Trigger Check** | Scan input against Sovereign Registry. | If `ui_layer`: yields & **STOPS**. If `diagnostic`: yields & **STOPS**. |
| **3** | **Context Prep** | Append user message to history. | - |
| **4** | **Multiplexer** | Launch `Engine Stream` + `Queue Watch` tasks. | race(Stream.next(), Queue.get()) |

---

## 3. UI Layer State

Nexus manages the "Window Manager" state for the frontend.

| Layer | Key | Default | Description |
| :--- | :--- | :--- | :--- |
| **Chat** | `chat` | Active | Main conversation stream. |
| **System** | `system` | Active | System status toasts/logs. |
| **Emoji** | `emoji` | Active | Floating emoji overlay reactions. |
| **Control** | `ui_control` | Inactive | Specialized HUD elements. |

---

## 4. The Multiplexer (The Box)

The `dispatch` loop runs a sophisticated `asyncio.wait(FIRST_COMPLETED)` loop that monitors two sources concurrently:

1.  **LLM Stream**: Tokens generated by the primary intelligence.
2.  **System Event Queue**: Asynchronous alerts from background processes (e.g., "Web search completed" or "Battery low").

**Logic**:
```python
while stream_active:
    done, _ = await asyncio.wait([stream_task, queue_task], return_when=FIRST_COMPLETED)
    if stream_task in done:
        yield token
    if queue_task in done:
        yield system_alert_event  # Injects directly into user stream
```
