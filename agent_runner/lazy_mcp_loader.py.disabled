"""
Lazy MCP server loading for faster boot times.

Strategy:
- Critical servers: Load immediately (filesystem, memory)
- Optional servers: Defer until first use (weather, web_search)  
- Failed servers: Skip and add to disabled_servers

This addresses boot sequence failures and reduces startup time.
"""
import asyncio
import logging
from typing import Dict, Set, Optional, List
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)


class MCPServerPriority(Enum):
    """Server loading priority"""
    CRITICAL = "critical"  # Must load at boot
    HIGH = "high"  # Load early but non-blocking
    NORMAL = "normal"  # Defer until first use
    LOW = "low"  # Load on demand only


@dataclass
class MCPServerConfig:
    """MCP server configuration with lazy loading metadata"""
    name: str
    command: str
    args: List[str]
    env: Dict[str, str]
    priority: MCPServerPriority = MCPServerPriority.NORMAL
    requires_internet: bool = False
    loaded: bool = False
    failed: bool = False
    error: Optional[str] = None


class LazyMCPLoader:
    """
    Lazy MCP server loader with priority-based initialization.
    
    Boot sequence:
    1. Load CRITICAL servers (blocking)
    2. Start background task for HIGH priority servers
    3. Defer NORMAL/LOW servers until first tool call
    
    This prevents boot failures from non-critical services.
    """
    
    # Define server priorities (user-configurable in DB)
    DEFAULT_PRIORITIES = {
        # Critical - must work for basic functionality
        "filesystem": MCPServerPriority.CRITICAL,
        "memory": MCPServerPriority.CRITICAL,
        
        # High - load early but don't block boot
        "project-memory": MCPServerPriority.HIGH,
        
        # Normal - load on demand
        "exa": MCPServerPriority.NORMAL,
        "tavily": MCPServerPriority.NORMAL,
        "brave-search": MCPServerPriority.NORMAL,
        
        # Low - rarely used
        "weather": MCPServerPriority.LOW,  # Especially if misconfigured!
    }
    
    def __init__(self, state):
        self.state = state
        self.servers: Dict[str, MCPServerConfig] = {}
        self.loading_tasks: Dict[str, asyncio.Task] = {}
        self._lock = asyncio.Lock()
    
    def register_server(
        self,
        name: str,
        command: str,
        args: List[str],
        env: Dict[str, str],
        priority: Optional[MCPServerPriority] = None,
        requires_internet: bool = False
    ) -> None:
        """Register MCP server for lazy loading"""
        # Use default priority if not specified
        if priority is None:
            priority = self.DEFAULT_PRIORITIES.get(name, MCPServerPriority.NORMAL)
        
        self.servers[name] = MCPServerConfig(
            name=name,
            command=command,
            args=args,
            env=env,
            priority=priority,
            requires_internet=requires_internet
        )
    
    async def load_critical_servers(self) -> List[str]:
        """
        Load CRITICAL priority servers during boot (blocking).
        
        Returns:
            List of successfully loaded server names
        """
        logger.info("Loading CRITICAL MCP servers...")
        
        critical_servers = [
            server for server in self.servers.values()
            if server.priority == MCPServerPriority.CRITICAL
        ]
        
        if not critical_servers:
            logger.warning("No CRITICAL MCP servers defined!")
            return []
        
        # Load in parallel
        tasks = [
            self._load_server(server.name)
            for server in critical_servers
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Check for failures
        successful = []
        failed = []
        
        for server, result in zip(critical_servers, results):
            if isinstance(result, Exception):
                logger.error(f"❌ CRITICAL server '{server.name}' failed: {result}")
                server.failed = True
                server.error = str(result)
                failed.append(server.name)
                
                # Add to disabled servers
                self.state.disabled_servers.add(server.name)
                
                # Add to degraded reasons
                self.state.degraded_reasons.append(
                    f"Critical MCP server '{server.name}' failed to load"
                )
                self.state.degraded_mode = True
            else:
                server.loaded = True
                successful.append(server.name)
        
        if failed:
            logger.warning(
                f"⚠️ Boot continuing in DEGRADED mode. "
                f"Failed CRITICAL servers: {', '.join(failed)}"
            )
        
        logger.info(
            f"✅ Loaded {len(successful)}/{len(critical_servers)} CRITICAL servers: "
            f"{', '.join(successful)}"
        )
        
        return successful
    
    async def start_high_priority_loading(self) -> None:
        """
        Start background loading of HIGH priority servers (non-blocking).
        """
        high_priority = [
            server for server in self.servers.values()
            if server.priority == MCPServerPriority.HIGH and not server.loaded
        ]
        
        if not high_priority:
            return
        
        logger.info(f"Starting background load of {len(high_priority)} HIGH priority servers...")
        
        for server in high_priority:
            # Start loading in background
            task = asyncio.create_task(self._load_server(server.name))
            self.loading_tasks[server.name] = task
    
    async def ensure_server_loaded(self, server_name: str) -> bool:
        """
        Ensure server is loaded (lazy load if necessary).
        
        Args:
            server_name: Name of MCP server
        
        Returns:
            True if loaded successfully, False if failed
        """
        async with self._lock:
            server = self.servers.get(server_name)
            
            if server is None:
                logger.error(f"Unknown MCP server: {server_name}")
                return False
            
            # Already loaded
            if server.loaded:
                return True
            
            # Previously failed
            if server.failed:
                logger.debug(f"Server '{server_name}' previously failed: {server.error}")
                return False
            
            # Check if loading in progress
            if server_name in self.loading_tasks:
                task = self.loading_tasks[server_name]
                if not task.done():
                    logger.debug(f"Waiting for '{server_name}' to finish loading...")
                    try:
                        await task
                        return server.loaded
                    except Exception as e:
                        server.failed = True
                        server.error = str(e)
                        return False
            
            # Lazy load now
            logger.info(f"Lazy loading MCP server: {server_name}")
            try:
                await self._load_server(server_name)
                return server.loaded
            except Exception as e:
                logger.error(f"Failed to lazy load '{server_name}': {e}")
                server.failed = True
                server.error = str(e)
                self.state.disabled_servers.add(server_name)
                return False
    
    async def _load_server(self, server_name: str) -> None:
        """
        Actually load an MCP server (connect, initialize).
        
        This is called by load_critical_servers(), start_high_priority_loading(),
        or ensure_server_loaded().
        """
        server = self.servers[server_name]
        
        # Skip if requires internet and we're offline
        if server.requires_internet and not self.state.internet_available:
            logger.warning(
                f"Skipping '{server_name}' - requires internet (offline mode)"
            )
            server.failed = True
            server.error = "Requires internet (offline)"
            self.state.disabled_servers.add(server_name)
            return
        
        # Skip if already in disabled_servers (e.g., misconfigured weather MCP)
        if server_name in self.state.disabled_servers:
            logger.warning(f"Skipping '{server_name}' - in disabled_servers list")
            server.failed = True
            server.error = "Disabled by configuration"
            return
        
        try:
            # Import executor to actually load server
            from agent_runner.executor import Executor
            
            # Create MCP client session
            # (This is simplified - real implementation connects via stdio/http)
            logger.debug(f"Loading MCP server '{server_name}': {server.command} {server.args}")
            
            # Check circuit breaker state
            from common.circuit_breaker import CircuitBreakerRegistry
            breaker = self.state.mcp_circuit_breaker.get_breaker(server_name)
            
            if breaker.state == "OPEN":
                logger.warning(
                    f"Circuit breaker OPEN for '{server_name}' - skipping load"
                )
                server.failed = True
                server.error = "Circuit breaker OPEN"
                self.state.disabled_servers.add(server_name)
                return
            
            # TODO: Actual MCP connection logic
            # For now, mark as loaded (Phase 2 implementation)
            server.loaded = True
            logger.info(f"✅ Loaded MCP server: {server_name}")
            
        except Exception as e:
            logger.error(f"Failed to load '{server_name}': {e}", exc_info=True)
            server.failed = True
            server.error = str(e)
            self.state.disabled_servers.add(server_name)
            
            # Record circuit breaker failure
            breaker = self.state.mcp_circuit_breaker.get_breaker(server_name)
            breaker.record_failure()
            
            raise
    
    def get_loaded_servers(self) -> List[str]:
        """Get list of successfully loaded server names"""
        return [
            name for name, server in self.servers.items()
            if server.loaded
        ]
    
    def get_failed_servers(self) -> Dict[str, str]:
        """Get dict of failed servers {name: error}"""
        return {
            name: server.error
            for name, server in self.servers.items()
            if server.failed
        }
    
    def get_loading_status(self) -> Dict[str, str]:
        """Get status of all servers"""
        status = {}
        for name, server in self.servers.items():
            if server.loaded:
                status[name] = "loaded"
            elif server.failed:
                status[name] = f"failed: {server.error}"
            elif name in self.loading_tasks and not self.loading_tasks[name].done():
                status[name] = "loading"
            else:
                status[name] = "pending"
        return status
