<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>AI Orchestrator Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='grad' x1='0%' y1='0%' x2='100%' y2='100%'><stop offset='0%' style='stop-color:%234f8bff;stop-opacity:1' /><stop offset='100%' style='stop-color:%234ade80;stop-opacity:1' /></linearGradient></defs><circle cx='50' cy='50' r='45' fill='url(%23grad)'/><path d='M30 50 L45 65 L70 35' stroke='%230b1020' stroke-width='6' stroke-linecap='round' stroke-linejoin='round' fill='none'/></svg>">
  <style>
    :root {
      color-scheme: dark light;

      /* Base Colors - Improved palette */
      --bg: #0b1020;
      --panel: #141a2a;
      --border: #29334d;
      --text: #f5f7ff;
      --muted: #9aa3c2;

      /* Primary Accent - Consistent blue */
      --accent: #4f8bff;
      --accent-soft: rgba(79, 139, 255, 0.12);
      --accent-hover: rgba(79, 139, 255, 0.2);

      /* Semantic Status Colors - Consistent pairs */
      --status-success: #4ade80;
      --status-success-bg: rgba(74, 222, 128, 0.12);
      --status-error: #ff6b81;
      --status-error-bg: rgba(255, 107, 129, 0.12);
      --status-warning: #facc15;
      --status-warning-bg: rgba(250, 204, 21, 0.12);
      --status-info: #4f8bff;
      --status-info-bg: rgba(79, 139, 255, 0.12);

      /* State Pairs - For items that change state */
      --state-active: var(--status-success);
      --state-active-bg: var(--status-success-bg);
      --state-inactive: var(--muted);
      --state-inactive-bg: rgba(154, 163, 194, 0.08);

      --state-enabled: var(--status-success);
      --state-enabled-bg: var(--status-success-bg);
      --state-disabled: var(--muted);
      --state-disabled-bg: var(--state-inactive-bg);

      --state-online: var(--status-success);
      --state-online-bg: var(--status-success-bg);
      --state-offline: var(--status-error);
      --state-offline-bg: var(--status-error-bg);

      --state-healthy: var(--status-success);
      --state-healthy-bg: var(--status-success-bg);
      --state-degraded: var(--status-warning);
      --state-degraded-bg: var(--status-warning-bg);
      --state-down: var(--status-error);
      --state-down-bg: var(--status-error-bg);

      /* Legacy aliases for backward compatibility */
      --ok: var(--status-success);
      --error: var(--status-error);
      --warn: var(--status-warning);

      /* Typography Scale - Consistent sizes */
      --font-xs: 0.65rem;
      /* 10.4px - Tiny labels, tags */
      --font-sm: 0.75rem;
      /* 12px - Small text, captions */
      --font-base: 0.85rem;
      /* 13.6px - Body text, default */
      --font-md: 0.95rem;
      /* 15.2px - Card titles, emphasis */
      --font-lg: 1.1rem;
      /* 17.6px - Section headers */
      --font-xl: 1.6rem;
      /* 25.6px - Page title */

      /* Font Families */
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;

      /* Spacing Scale */
      --space-xs: 0.25rem;
      --space-sm: 0.5rem;
      --space-md: 1rem;
      --space-lg: 1.5rem;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 1.5rem;
      font-family: var(--sans);
      background: radial-gradient(circle at top, #141a2a 0, #050814 55%, #02030a 100%);
      color: var(--text);
    }

    h1 {
      font-size: var(--font-xl);
      margin: 0 0 0.5rem;
      letter-spacing: 0.04em;
      color: var(--text);
    }

    .subtitle {
      margin: 0 0 var(--space-lg);
      color: var(--muted);
      font-size: var(--font-sm);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 3fr);
      gap: 1rem;
    }

    .health-bar {
      margin-bottom: var(--space-md);
      padding: 0.6rem 0.9rem;
      border-radius: 0.6rem;
      font-size: var(--font-base);
      display: none;
      align-items: center;
      gap: 0.6rem;
      background: var(--panel);
      border: 1px solid var(--border);
    }

    .health-bar.has-issues {
      border-color: var(--status-warning);
      background: var(--status-warning-bg);
    }

    .health-bar.has-errors {
      border-color: var(--status-error);
      background: var(--status-error-bg);
    }

    .health-bar .message-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .health-item {
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }

    .health-item.error {
      color: var(--status-error);
    }

    .health-item.warn {
      color: var(--status-warning);
    }

    .health-item.ok {
      color: var(--status-success);
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      border-bottom: 1px solid var(--border);
      padding-bottom: 0.5rem;
      overflow-x: auto;
    }

    .tab {
      padding: var(--space-sm) var(--space-md);
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: var(--font-base);
      font-weight: 500;
      color: var(--muted);
      transition: all 0.2s;
      white-space: nowrap;
    }

    .tab:hover {
      background: var(--accent-soft);
      color: var(--text);
    }

    .tab.active {
      background: var(--accent);
      color: white;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Single screen card */
    .single-screen-card {
      min-height: calc(100vh - 200px);
      display: flex;
      flex-direction: column;
    }

    .prompt-box {
      flex: 1;
      font-family: var(--mono);
      font-size: var(--font-base);
      line-height: 1.5;
      background: #020617;
      padding: var(--space-lg);
      border-radius: 0.8rem;
      border: 1px solid var(--border);
      overflow: auto;
      color: var(--text);
      white-space: pre-wrap;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 0.9rem;
      border: 1px solid var(--border);
      padding: 1rem 1.1rem;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.75rem;
    }

    .card-title {
      font-size: var(--font-md);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
      border-radius: 999px;
      padding: 0.14rem 0.55rem;
      font-size: var(--font-xs);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      border: 1px solid var(--border);
      color: var(--muted);
      background: var(--panel);
    }

    .tag-dot {
      width: 0.4rem;
      height: 0.4rem;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 0 4px var(--accent-soft);
    }

    .tag-ok .tag-dot {
      background: var(--status-success);
      box-shadow: 0 0 0 4px var(--status-success-bg);
    }

    .tag-error .tag-dot {
      background: var(--status-error);
      box-shadow: 0 0 0 4px var(--status-error-bg);
    }

    .tag-warn .tag-dot {
      background: var(--status-warning);
      box-shadow: 0 0 0 4px var(--status-warning-bg);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .kpi {
      padding: 0.55rem 0.6rem;
      border-radius: 0.7rem;
      background: radial-gradient(circle at top left, rgba(79, 139, 255, 0.22), transparent 60%);
      border: 1px solid rgba(148, 163, 184, 0.25);
    }

    .kpi-label {
      font-size: var(--font-xs);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin-bottom: 0.15rem;
    }

    .kpi-value {
      font-family: var(--mono);
      font-size: var(--font-base);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      word-break: break-all;
      max-width: 100%;
      color: var(--text);
    }

    .kpi-value-strong {
      color: var(--status-success);
      font-weight: 600;
    }

    .kpi-small {
      font-size: var(--font-sm);
      color: var(--muted);
    }

    /* Status value classes for consistent state display */
    .status-success {
      color: var(--status-success);
    }

    .status-error {
      color: var(--status-error);
    }

    .status-warning {
      color: var(--status-warning);
    }

    .status-info {
      color: var(--status-info);
    }

    .status-muted {
      color: var(--muted);
    }

    .section-title {
      font-size: var(--font-base);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin: 0.4rem 0 0.3rem;
    }

    .muted {
      color: var(--muted);
      font-size: 0.8rem;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      margin-bottom: 0.6rem;
    }

    .controls input {
      font-family: var(--mono);
      font-size: 0.78rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.4rem;
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
      min-width: 0;
    }

    .controls input::placeholder {
      color: rgba(148, 163, 184, 0.8);
    }

    .controls button {
      border-radius: 999px;
      border: 1px solid rgba(79, 139, 255, 0.7);
      background: radial-gradient(circle at top, var(--accent), #2563eb);
      color: white;
      padding: 0.32rem 0.9rem;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      box-shadow: 0 10px 25px rgba(37, 99, 235, 0.45);
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .controls button:disabled {
      opacity: 0.6;
      cursor: default;
      box-shadow: none;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.12rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      font-size: 0.7rem;
      color: var(--muted);
      margin-right: 0.25rem;
      margin-bottom: 0.2rem;
    }

    .scrollbox {
      border-radius: 0.6rem;
      background: #020617;
      border: 1px solid rgba(30, 64, 175, 0.7);
      padding: 0.5rem 0.6rem;
      font-family: var(--mono);
      font-size: 0.78rem;
      color: #e5e7eb;
      max-height: 260px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    code {
      font-family: var(--mono);
      background: rgba(15, 23, 42, 0.9);
      padding: 0.05rem 0.25rem;
      border-radius: 0.3rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
      font-size: 0.78rem;
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .error-text {
      color: var(--error);
      font-size: 0.78rem;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .card-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }

      .controls {
        width: 100%;
        flex-wrap: wrap;
      }

      .controls input,
      .controls select {
        width: 100%;
        margin-bottom: 0.5rem;
      }

      .grid {
        grid-template-columns: 1fr;
      }

      .kpi {
        min-width: auto;
      }

      h1 {
        font-size: var(--font-lg);
      }

      .tab {
        font-size: var(--font-sm);
        padding: 0.4rem 0.6rem;
      }

      .tabs {
        overflow-x: auto;
        flex-wrap: nowrap;
      }
    }

    @media (max-width: 480px) {
      body {
        padding: 0.75rem;
      }

      .card {
        padding: 0.75rem;
      }

      .card-title {
        font-size: var(--font-base);
      }

      .kpi-label {
        font-size: var(--font-xs);
      }

      .kpi-value {
        font-size: var(--font-md);
      }

      .tab {
        font-size: var(--font-xs);
        padding: 0.3rem 0.5rem;
      }
    }
  </style>
</head>

<body>
  <header style="margin-bottom:1rem;">
    <h1>AI Orchestrator Dashboard</h1>
    <p class="subtitle">Local router + agent-runner + MCP/RAG status, fetched live from the running services.</p>
  </header>

  <div id="health-bar" class="health-bar">
    <div id="health-message-list" class="message-list"></div>
  </div>

  <div class="tabs">
    <div class="tab active" onclick="showTab('overview')">üìä Overview</div>
    <div class="tab" onclick="showTab('model-services')">üîó Model Services</div>
    <div class="tab" onclick="showTab('tools')">üîß Tools &amp; MCP</div>
    <div class="tab" onclick="showTab('activity')">üìà Activity</div>
    <div class="tab" onclick="showTab('system-prompt')">üí¨ System Prompt</div>
    <div class="tab" onclick="showTab('memory')">üß† Memory</div>
    <div class="tab" onclick="showTab('idle-tasks')">‚è∞ Idle Tasks</div>
    <div class="tab" onclick="showTab('tasks')">‚öôÔ∏è Tasks</div>
    <div class="tab" onclick="showTab('config')">‚öôÔ∏è Config</div>
    <div class="tab" onclick="showTab('info')">üß¨ Model Intel</div>
    <div class="tab" onclick="showTab('documentation')">üìö Documentation</div>
    <div class="tab" onclick="showTab('debug')">üêõ Debug</div>
  </div>

  <div id="overview" class="tab-content active">
    <div class="layout">
      <!-- Left: status + config -->
      <section class="card">
        <div class="card-header">
          <div class="card-title">Status &amp; Configuration</div>
          <div id="status-tag" class="tag">
            <span class="tag-dot"></span>
            <span id="status-text">Checking...</span>
          </div>
        </div>

        <div class="controls">
          <label class="muted" style="font-size:var(--font-sm);">Router base:</label>
          <input id="router-base" type="text" value="" />
          <input id="auth-token" type="password" placeholder="Optional ROUTER_AUTH_TOKEN" />
          <button id="save-auth-token-btn" type="button" title="Save auth token to config.yaml and restart router">Save
            Token</button>
          <button id="refresh-btn" type="button">Refresh</button>
          <!-- Auth token warning banner -->
          <div id="auth-token-warning"
            style="display:none; margin-top:0.5rem; padding:0.75rem; background:rgba(250, 204, 21, 0.15); border:1px solid var(--status-warning); border-radius:0.5rem; color:var(--status-warning); font-size:var(--font-sm);">
            <strong>‚ö†Ô∏è Authentication Required:</strong> Router authentication is enabled but no token is set. Some
            features may not work. Please enter your auth token above.
          </div>
          <button id="reload-btn" type="button" title="POST /admin/reload (requires token if enabled)">Reload
            providers</button>
          <button id="clear-cache-btn" type="button" title="POST /admin/cache/clear (requires token if enabled)">Clear
            cache</button>
          <button id="start-agent-btn" type="button" title="POST /admin/start-agent (requires token if enabled)"
            style="display:none;">Start agent</button>
          <button id="stop-agent-btn" type="button" title="POST /admin/stop-agent (requires token if enabled)"
            style="display:none;">Stop agent</button>
          <button id="restart-agent-btn" type="button" title="POST /admin/restart-agent (requires token if enabled)"
            style="display:none;">Restart agent</button>
          <button id="restart-router-btn" type="button" title="POST /admin/restart-router (requires token if enabled)"
            style="display:none;">Restart router</button>
          <button id="restart-all-btn" type="button" title="POST /admin/restart-all (requires token if enabled)"
            style="display:none;">Restart all</button>
          <button id="open-docs-btn" type="button" title="Open router API docs"
            onclick="window.open(window.location.origin + '/docs', '_blank')">API Docs</button>
        </div>

        <div class="section-title" style="margin-top:1rem; margin-bottom:0.5rem;">Service Status</div>
        <div class="grid">
          <div class="kpi">
            <div class="kpi-label">Router</div>
            <div class="kpi-value" id="router-ok">‚Äî</div>
            <div class="kpi-small" id="router-version"></div>
          </div>
          <div class="kpi">
            <div class="kpi-label">Agent-Runner</div>
            <div class="kpi-value" id="agent-ok">‚Äî</div>
            <div class="kpi-small" id="agent-model"></div>
          </div>
          <div class="kpi">
            <div class="kpi-label">Dashboard Health</div>
            <div class="kpi-value" id="dashboard-health">OK</div>
            <div class="kpi-small" id="dashboard-details">Connected locally</div>
          </div>
        </div>

        <div class="section-title" style="margin-top:1rem; margin-bottom:0.5rem;">Model Configuration</div>
        <div class="grid">
          <div class="kpi">
            <div class="kpi-label">MCP/Tool Access</div>
            <div class="kpi-value" id="mcp-toggle-status" style="font-size:var(--font-sm);">Disabled</div>
            <div class="kpi-small" id="mcp-toggle-details">Direct model access (no tools)</div>
            <label
              style="margin-top:0.3rem; display:flex; align-items:center; gap:0.5rem; cursor:pointer; padding:0.3rem; border-radius:0.3rem; background:var(--panel); border:1px solid var(--border);">
              <input type="checkbox" id="mcp-toggle" style="width:1.2rem; height:1.2rem; cursor:pointer;">
              <span style="font-size:var(--font-sm); color:var(--text);">Enable MCP/Tool Access</span>
            </label>
            <div class="muted"
              style="margin-top:0.3rem; font-size:var(--font-xs); padding:0.3rem; background:var(--bg); border-radius:0.3rem;">
              When enabled, requests route through agent-runner with full tool access (files, MCP servers, memory). When
              disabled, requests go directly to the model for faster responses.
            </div>
          </div>
          <div class="kpi">
            <div class="kpi-label">Last Persona</div>
            <div class="kpi-value" id="last-persona">‚Äî</div>
            <div class="kpi-small" id="persona-mission">Waiting for query...</div>
          </div>
        </div>

        <div class="section-title" style="margin-top:1rem; margin-bottom:0.5rem;">System Health</div>
        <div class="grid">
          <div class="kpi">
            <div class="kpi-label">Database Status</div>
            <div class="kpi-value" id="database-status" style="color:var(--muted);">‚Äî</div>
            <div class="kpi-small" id="database-details">Checking...</div>
          </div>
          <div class="kpi">
            <div class="kpi-label">Internet Status</div>
            <div class="kpi-value" id="internet-status">‚Äî</div>
            <div class="kpi-small" id="internet-details"></div>
          </div>
          <div class="kpi">
            <div class="kpi-label">Hardware Limits</div>
            <div class="kpi-value" id="hardware-limits">‚Äî</div>
            <div class="kpi-small" id="hardware-details"></div>
          </div>
          <div class="kpi">
            <div class="kpi-label">System Mode</div>
            <div class="kpi-value" id="system-mode">‚Äî</div>
            <div class="kpi-small" id="system-mode-details"></div>
          </div>
          <div class="kpi">
            <div class="kpi-label">Task Server</div>
            <div class="kpi-value" id="task-server-status" style="color:var(--muted);">‚Äî</div>
            <div class="kpi-small" id="task-server-details">Checking...</div>
          </div>
        </div>

        <div class="section-title" style="margin-top:1rem; margin-bottom:0.5rem;">Router Configuration</div>
        <div class="grid">
          <div class="kpi">
            <div class="kpi-label">Providers loaded</div>
            <div class="kpi-value" id="providers-count">‚Äî</div>
            <div class="kpi-small" id="providers-list"></div>
          </div>
          <div class="kpi">
            <div class="kpi-label">Auth &amp; Concurrency</div>
            <div class="kpi-value" id="auth-info">‚Äî</div>
            <div class="kpi-small" id="concurrency-info"></div>
          </div>
        </div>

      </section>
    </div>
  </div>

  <div id="model-services" class="tab-content">
    <div class="layout">
      <section class="card">
        <div class="card-header">
          <div class="card-title">Model-to-Service Mapping</div>
        </div>
        <div class="muted" style="margin-bottom:1rem;">Shows which models are configured for each service in the system.
        </div>
        <div id="model-services-content" style="font-size:var(--font-base); line-height:1.8;">
          <div class="muted">Loading model service mappings...</div>
        </div>
      </section>
    </div>
  </div>

  <div id="tools" class="tab-content">
    <div class="layout">
      <section class="card">
        <div class="card-header">
          <div class="card-title">MCP Servers &amp; Tools</div>
        </div>
        <div id="mcp-badges" style="margin-bottom:1rem;"></div>
        <div id="circuit-breaker-status" style="margin-bottom:1rem; font-size:var(--font-base);"></div>
        <div id="tool-usage-breakdown" style="font-size:var(--font-base); line-height:1.6; margin-bottom:1rem;">‚Äî</div>
        <div id="tool-performance-chart"
          style="min-height:200px; padding:1rem; background:rgba(15,23,42,0.5); border-radius:0.5rem; border:1px solid var(--border);">
          <div class="muted">Tool performance visualization will appear here after tool usage.</div>
        </div>
      </section>

      <section class="card" id="disabled-mcp-servers-card">
        <div class="card-header">
          <div class="card-title">‚ö†Ô∏è Disabled MCP Servers</div>
        </div>
        <div id="disabled-servers-list" style="padding:0.5rem 0;">
          <div class="muted" style="padding:0.5rem; text-align:center;">Loading...</div>
        </div>
        <div class="muted" style="margin-top:0.5rem; font-size:var(--font-sm);">
          These servers are disabled due to circuit breaker failures. They will automatically retry after the timeout
          period.
        </div>
      </section>

      <section class="card">
        <div class="card-header">
          <div class="card-title">MCP Server Management</div>
        </div>
        <div class="muted" style="margin-bottom:1rem;">Upload MCP server configuration files (JSON, YAML, or text). The
          LLM will analyze and add them automatically.</div>

        <div style="margin-bottom:1rem; display:flex; flex-direction:column; gap:0.5rem;">
          <input type="file" id="mcp-config-file" style="display:none;" onchange="uploadMCPConfig()">
          <div style="display:flex; gap:1rem;">
            <button onclick="$('mcp-config-file').click()" class="tag"
              style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent); padding: 0.6rem 1.2rem; font-size: 0.9rem;">üìÅ
              Upload / Paste Config</button>
            <button onclick="window.open('v2/mcp_wizard.html', '_blank')" class="tag"
              style="cursor:pointer; background:var(--accent); color:white; border:none; padding: 0.6rem 1.2rem; font-size: 0.9rem;">‚ú®
              Open Smart Import Wizard</button>
          </div>
          <div id="mcp-upload-status" class="muted" style="margin-top:0.5rem; font-size:0.85rem; min-height:1.2em;">
          </div>
        </div>

        <div class="muted" style="margin-bottom:1rem;">Reload MCP servers and rediscover tools without restarting the
          agent-runner.</div>
        <div class="controls">
          <button onclick="reloadMCPServers()" class="tag"
            style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent);">Reload MCP
            Servers</button>
        </div>
        <div id="mcp-reload-status" style="margin-top:0.5rem; font-size:0.85rem;"></div>
      </section>
    </div>
  </div>

  <div id="activity" class="tab-content">
    <div class="layout">
      <section class="card" style="grid-column: 1 / -1;">
        <div class="card-header">
          <div class="card-title">Recent Activity</div>
          <div class="controls">
            <input type="text" id="activity-search" placeholder="Search activity..."
              style="padding:0.3rem 0.5rem; font-size:var(--font-sm); border-radius:0.3rem; border:1px solid var(--border); background:var(--panel); color:var(--text); width:200px;" />
            <select id="activity-filter"
              style="padding:0.3rem 0.5rem; font-size:var(--font-sm); border-radius:0.3rem; border:1px solid var(--border); background:var(--panel); color:var(--text);">
              <option value="all">All</option>
              <option value="success">Success only</option>
              <option value="error">Errors only</option>
            </select>
            <button onclick="exportActivity()" class="tag"
              style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent);">Export</button>
          </div>
        </div>
        <div id="recent-activity" class="scrollbox" style="max-height:500px; font-size:0.85rem;">
          <div class="muted">No requests yet.</div>
        </div>
      </section>

      <section class="card">
        <div class="card-header">
          <div class="card-title">Health Alerts Log</div>
        </div>
        <div id="alerts-list" class="scrollbox" style="max-height:300px; font-size:0.85rem;">‚Äî</div>
      </section>

      <section class="card">
        <div class="card-header">
          <div class="card-title">Model Usage Stats</div>
        </div>
        <div id="model-usage" style="font-size:0.85rem; line-height:1.6;">‚Äî</div>
      </section>
    </div>
  </div>

  <div id="system-prompt" class="tab-content">
    <section class="card single-screen-card">
      <div class="card-header">
        <div class="card-title">Current Agent System Prompt</div>
        <div class="controls">
          <button onclick="refreshSystemPrompt()" class="tag"
            style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent);">Refresh Prompt</button>
          <button onclick="copySystemPrompt()" class="tag"
            style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent);">Copy Prompt</button>
          <button onclick="togglePromptSections()" class="tag"
            style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent);"
            id="toggle-sections-btn">Show Sections</button>
        </div>
      </div>
      <div class="muted" style="margin-bottom:1rem;">This is the dynamic prompt currently being injected into every
        agent request. It updates based on active persona, recalled memories, and system state.</div>
      <div id="current-system-prompt" class="prompt-box"
        style="white-space: pre-wrap; font-family: var(--mono); font-size: var(--font-base); line-height: 1.5;">Loading
        prompt...</div>
    </section>
  </div>

  <div id="memory" class="tab-content">
    <div class="layout">
      <section class="card" style="grid-column: 1 / -1;">
        <div class="card-header">
          <div class="card-title">Knowledge Graph Memory</div>
          <div class="controls">
            <div id="memory-health-tag" class="tag" style="margin-right: 0.5rem;">
              <span class="tag-dot"></span>
              <span id="memory-health-text">Status...</span>
            </div>
            <input type="text" id="memory-search" placeholder="Search facts..."
              style="padding:0.3rem 0.5rem; font-size:var(--font-sm); border-radius:0.3rem; border:1px solid var(--border); background:var(--panel); color:var(--text); width:200px;" />
            <select id="memory-filter"
              style="padding:0.3rem 0.5rem; font-size:var(--font-sm); border-radius:0.3rem; border:1px solid var(--border); background:var(--panel); color:var(--text);">
              <option value="all">All facts</option>
              <option value="entity">By entity</option>
              <option value="relation">By relation</option>
            </select>
            <button onclick="indexArchitecture()" class="tag"
              style="cursor:pointer; background:rgba(148,163,184,0.1); border-color:var(--accent); color:var(--accent);">Index
              Architecture</button>
            <button onclick="refreshMemory()" class="tag"
              style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent);">Refresh Memory</button>
            <button onclick="exportMemory()" class="tag"
              style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent);">Export</button>
          </div>
        </div>
        <div class="muted" style="margin-bottom:1rem;">This is the persistent knowledge graph stored in SurrealDB.</div>
        <div id="memory-list" class="scrollbox" style="max-height:500px; font-size:0.85rem;">
          Loading memory...
        </div>
      </section>
    </div>
  </div>

  <div id="idle-tasks" class="tab-content">
    <div class="layout" style="grid-template-columns: repeat(4, 1fr); gap: 1rem;">
      <section class="card" style="grid-column: 1 / -1;">
        <div class="card-header">
          <div class="card-title">Task Scheduler</div>
          <div class="controls">
            <button onclick="refreshScheduler()" class="tag"
              style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent);">Refresh</button>
          </div>
        </div>
        <div class="muted" style="margin-bottom:1rem;">Tasks are organized by priority and scheduled execution time.
          Critical tasks notify on failure.</div>
      </section>

      <section class="card">
        <div class="card-header">
          <div class="card-title">Next Up</div>
          <div class="tag" style="background:var(--accent-soft); color:var(--accent);" id="next-up-count">0</div>
        </div>
        <div class="muted" style="margin-bottom:0.5rem; font-size:0.85rem;">Tasks running in the next minute</div>
        <div id="next-up-tasks" class="scrollbox" style="max-height:500px; font-size:0.85rem;">
          Loading...
        </div>
      </section>

      <section class="card">
        <div class="card-header">
          <div class="card-title">Next Hour</div>
          <div class="tag" style="background:var(--accent-soft); color:var(--accent);" id="next-hour-count">0</div>
        </div>
        <div class="muted" style="margin-bottom:0.5rem; font-size:0.85rem;">Tasks scheduled in the next hour</div>
        <div id="next-hour-tasks" class="scrollbox" style="max-height:500px; font-size:0.85rem;">
          Loading...
        </div>
      </section>

      <section class="card">
        <div class="card-header">
          <div class="card-title">Next Week</div>
          <div class="tag" style="background:var(--accent-soft); color:var(--accent);" id="next-week-count">0</div>
        </div>
        <div class="muted" style="margin-bottom:0.5rem; font-size:0.85rem;">Tasks scheduled this week</div>
        <div id="next-week-tasks" class="scrollbox" style="max-height:500px; font-size:0.85rem;">
          Loading...
        </div>
      </section>

      <section class="card">
        <div class="card-header">
          <div class="card-title">Long Term</div>
          <div class="tag" style="background:var(--accent-soft); color:var(--accent);" id="long-term-count">0</div>
        </div>
        <div class="muted" style="margin-bottom:0.5rem; font-size:0.85rem;">Tasks beyond a week</div>
        <div id="long-term-tasks" class="scrollbox" style="max-height:500px; font-size:0.85rem;">
          Loading...
        </div>
      </section>
    </div>
  </div>

  <div id="tasks" class="tab-content">
    <div class="layout">
      <section class="card" style="grid-column: 1 / -1;">
        <div class="card-header">
          <div class="card-title">Background Tasks</div>
          <div class="controls">
            <button onclick="refreshTasks()" class="tag"
              style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent);">Refresh</button>
          </div>
        </div>
        <div class="muted" style="margin-bottom:1rem;">Manage and monitor background tasks. You can trigger tasks
          manually or view their status.</div>
        <div id="tasks-list" class="grid" style="grid-template-columns: 1fr; gap: 1rem;">
          Loading tasks...
        </div>
      </section>
    </div>
  </div>

  <div id="config" class="tab-content">
    <div class="layout">
      <section class="card">
        <div class="card-header">
          <div class="card-title">Configuration</div>
        </div>
        <div class="muted" style="margin-bottom:1rem;">Edit system configuration files.</div>
        <div class="controls" style="display:flex; flex-direction:column; gap:0.5rem;">
          <div style="display:flex; gap:0.5rem; align-items:center;">
            <label for="file-selector" style="font-size:var(--font-sm); color:var(--muted);">File:</label>
            <select id="file-selector"
              style="flex:1; padding:0.4rem; border-radius:0.3rem; border:1px solid var(--border); background:var(--panel); color:var(--text); font-size:var(--font-sm);">
              <option value="config/config.yaml">config.yaml</option>
              <option value="providers.yaml">providers.yaml</option>
              <option value="config/mcp_manifests/mcp_servers.json">mcp_servers.json</option>
              <option value="router.env">router.env</option>
              <option value="agent_runner/agent_runner.env">agent_runner.env</option>
            </select>
            <button id="edit-file-btn" type="button" title="Open file editor in new window">Edit</button>
          </div>
        </div>
      </section>
    </div>
  </div>

  <div id="info" class="tab-content">
    <div class="layout">
      <section class="card" style="grid-column: 1 / -1;">
        <div class="card-header">
          <div class="card-title">Model Intelligence &amp; Qualities</div>
        </div>
        <div class="muted" style="margin-bottom:1rem;">Specialized skills and strengths for each model in your fleet.
        </div>
        <div id="model-skills-list" class="grid"
          style="grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem;">
          Loading qualities...
        </div>
      </section>
    </div>
  </div>

  <div id="documentation" class="tab-content">
    <div class="layout">
      <section class="card" style="grid-column: 1 / -1;">
        <div class="card-header">
          <div class="card-title">Documentation</div>
          <button onclick="refreshDocumentation()" class="tag"
            style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent);">Refresh</button>
        </div>
        <div class="muted" style="margin-bottom:1rem;">Browse all available documentation files.</div>
        <div style="display: grid; grid-template-columns: 300px 1fr; gap: 1rem; min-height: 600px;">
          <div style="border-right: 1px solid var(--border); padding-right: 1rem;">
            <div style="margin-bottom: 1rem;">
              <input type="text" id="doc-search" placeholder="Search docs..."
                style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;"
                oninput="filterDocumentation()" />
            </div>
            <div id="docs-list" class="scrollbox" style="max-height: 550px; font-size: 0.9rem;">
              Loading documentation...
            </div>
          </div>
          <div>
            <div id="doc-content" class="scrollbox"
              style="max-height: 600px; padding: 1rem; background: var(--bg-soft); border-radius: 0.25rem; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.9rem; line-height: 1.6;">
              <div class="muted" style="text-align: center; padding: 2rem;">
                Select a document from the list to view its contents
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <div id="debug" class="tab-content">
    <div class="layout">
      <section class="card" style="grid-column: 1 / -1;">
        <div class="card-header">
          <div class="card-title">üêõ Dashboard Debug & Insights</div>
          <div style="display:flex; gap:0.5rem; align-items:center;">
            <button onclick="refreshDebugInfo()" class="tag"
              style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent);">Refresh</button>
            <label style="display:flex; align-items:center; gap:0.3rem; cursor:pointer; font-size:0.85rem;">
              <input type="checkbox" id="debug-mode-toggle" onchange="toggleDebugMode()"
                style="width:1rem; height:1rem; cursor:pointer;">
              <span>Debug Mode</span>
            </label>
          </div>
        </div>
        <div class="muted" style="margin-bottom:1rem;">View dashboard errors, patterns, and insights for
          troubleshooting.</div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
          <div>
            <h3 style="margin-bottom: 0.5rem; font-size: 1rem;">üìä Insights</h3>
            <div id="debug-insights" class="scrollbox"
              style="max-height: 400px; padding: 1rem; background: var(--bg-soft); border-radius: 0.25rem; font-size: 0.85rem;">
              Loading insights...
            </div>
          </div>
          <div>
            <h3 style="margin-bottom: 0.5rem; font-size: 1rem;">üî¥ Recent Errors (Last 24h)</h3>
            <div id="debug-errors" class="scrollbox"
              style="max-height: 400px; padding: 1rem; background: var(--bg-soft); border-radius: 0.25rem; font-size: 0.85rem;">
              Loading errors...
            </div>
          </div>
        </div>

        <div>
          <h3 style="margin-bottom: 0.5rem; font-size: 1rem;">üìà Error Patterns</h3>
          <div id="debug-patterns" class="scrollbox"
            style="max-height: 300px; padding: 1rem; background: var(--bg-soft); border-radius: 0.25rem; font-size: 0.85rem;">
            Loading patterns...
          </div>
        </div>

        <div id="debug-trends"
          style="margin-top:1rem; padding:1rem; background:var(--bg-soft); border-radius:0.25rem; font-size:0.85rem; display:none;">
          <strong>Error Trends (Last 24h):</strong>
          <div id="trend-chart" style="margin-top:0.5rem; min-height:100px;"></div>
        </div>
      </section>
    </div>
  </div>

  <script>
    // ============================================================================
    // CONSTANTS
    // ============================================================================
    // Debug mode state
    let debugMode = localStorage.getItem("dashboard_debug_mode") === "true";
    let lastRequestId = null;

    const PORTS = {
      ROUTER: 5455,
      AGENT: 5460
    };

    const CSS_VARS = {
      OK: "var(--ok)",
      ERROR: "var(--error)",
      WARN: "var(--warn)",
      ACCENT: "var(--accent)",
      MUTED: "var(--muted)",
      TEXT: "var(--text)"
    };

    const CLASS_NAMES = {
      TAG_OK: "tag-ok",
      TAG_ERROR: "tag-error",
      TAG_WARN: "tag-warn",
      KPI_VALUE_STRONG: "kpi-value-strong",
      KPI_VALUE: "kpi-value"
    };

    const STORAGE_KEYS = {
      MANUALLY_SET_ACTIVE_LLM: "manuallySetActiveLLM"
    };

    const REFRESH_INTERVAL = 10000; // 10 seconds
    const SYSTEM_PROMPT_REFRESH_INTERVAL = 5000; // 5 seconds

    // ============================================================================
    // UTILITY FUNCTIONS
    // ============================================================================
    const $ = (id) => document.getElementById(id);

    /**
     * Safely set text content of an element
     */
    function safeSetText(id, text) {
      const el = $(id);
      if (el) el.textContent = text || "";
    }

    /**
     * Safely set innerHTML of an element
     */
    function safeSetHTML(id, html) {
      const el = $(id);
      if (el) el.innerHTML = html || "";
    }

    /**
     * Safely set style property of an element
     */
    function safeSetStyle(id, property, value) {
      const el = $(id);
      if (el) el.style[property] = value;
    }

    /**
     * Safely add/remove classes from an element
     */
    function safeToggleClass(id, className, add) {
      const el = $(id);
      if (el) {
        if (add) {
          el.classList.add(className);
        } else {
          el.classList.remove(className);
        }
      }
    }

    /**
     * Get router base URL from input field
     */
    function getRouterBase() {
      const baseEl = $("router-base");
      if (!baseEl) {
        // Fallback: try to construct from current location
        const currentHost = window.location.hostname;
        const currentPort = window.location.port;
        if (currentPort && currentPort === String(PORTS.ROUTER)) {
          return `${window.location.protocol}//${currentHost}:${PORTS.ROUTER}`;
        }
        return "";
      }
      const base = baseEl.value.trim();
      if (!base) {
        // If empty, try localStorage or construct from current location
        const savedBase = localStorage.getItem("router_base_url");
        if (savedBase) return savedBase;
        const currentHost = window.location.hostname;
        return `http://${currentHost}:${PORTS.ROUTER}`;
      }
      return base.replace(/\/+$/, "");
    }

    /**
     * Get agent base URL from router base
     */
    function getAgentBase(base) {
      if (!base) base = getRouterBase();
      if (!base) return "";

      // Handle URL with port (e.g., http://127.0.0.1:5455)
      const routerPort = `:${PORTS.ROUTER}`;
      if (base.includes(routerPort)) {
        return base.replace(routerPort, `:${PORTS.AGENT}`);
      }

      // Handle URL without port or with trailing slash
      const cleanBase = base.replace(/\/+$/, "");
      // If it already has a port, don't add another
      if (cleanBase.match(/:\d+$/)) {
        return cleanBase;
      }
      // Otherwise, construct agent URL from router base
      // If router base is http://127.0.0.1:5455, agent should be http://127.0.0.1:5460
      const urlMatch = cleanBase.match(/^(https?:\/\/[^:]+)(?::\d+)?(\/.*)?$/);
      if (urlMatch) {
        const protocolHost = urlMatch[1];
        const path = urlMatch[2] || "";
        return `${protocolHost}:${PORTS.AGENT}${path}`;
      }

      // Fallback: just append port
      return `${cleanBase}:${PORTS.AGENT}`;
    }

    /**
     * Get auth token from input field
     */
    function getAuthToken() {
      const tokenEl = $("auth-token");
      if (!tokenEl) {
        // Fallback to localStorage if element doesn't exist yet
        return localStorage.getItem("router_auth_token") || "";
      }
      const token = tokenEl.value.trim();
      // Save to localStorage when token is entered
      if (token) {
        localStorage.setItem("router_auth_token", token);
      }
      return token || localStorage.getItem("router_auth_token") || "";
    }

    /**
     * Build headers object for API requests
     */
    function getHeaders(token) {
      const headers = { "Content-Type": "application/json", "Accept": "application/json" };
      if (token) headers["Authorization"] = "Bearer " + token;
      return headers;
    }

    // ============================================================================
    // TAB REGISTRY
    // ============================================================================
    const TAB_REGISTRY = {
      'system-prompt': {
        onShow: () => {
          refreshSystemPrompt();
          if (window.systemPromptInterval) clearInterval(window.systemPromptInterval);
          window.systemPromptInterval = setInterval(refreshSystemPrompt, SYSTEM_PROMPT_REFRESH_INTERVAL);
        },
        onHide: () => {
          if (window.systemPromptInterval) {
            clearInterval(window.systemPromptInterval);
            window.systemPromptInterval = null;
          }
        }
      },
      'memory': {
        onShow: () => refreshMemory()
      },
      'tools': {
        onShow: () => {
          // Tools tab - no special action needed
        }
      },
      'info': {
        onShow: () => {
          // Model intelligence is loaded in refresh()
        }
      },
      'documentation': {
        onShow: () => refreshDocumentation()
      },
      'debug': {
        onShow: () => refreshDebugInfo()
      },
      'idle-tasks': {
        onShow: () => {
          refreshScheduler();
          // Set up auto-refresh every 30 seconds for idle tasks
          if (window.idleTasksInterval) clearInterval(window.idleTasksInterval);
          window.idleTasksInterval = setInterval(refreshScheduler, 30000);
        },
        onHide: () => {
          if (window.idleTasksInterval) {
            clearInterval(window.idleTasksInterval);
            window.idleTasksInterval = null;
          }
        }
      },
      'tasks': {
        onShow: () => refreshTasks(),
        onHide: () => {
          // Clear any intervals if needed
        }
      },
      'model-services': {
        onShow: () => refreshModelServices()
      },
      'activity': {
        onShow: () => {
          // Activity is refreshed in main refresh() function
          // But ensure it's rendered if we have data
          if (rawActivityData && rawActivityData.length > 0) {
            renderActivity(rawActivityData);
          }
        }
      }
    };

    function showTab(tabId) {
      // Hide all tabs
      document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));

      // Show selected tab content
      const content = $(tabId);
      if (content) content.classList.add('active');

      // Find and activate tab button - use exact onclick match
      const tabs = document.querySelectorAll('.tab');
      for (const tab of tabs) {
        const onclick = tab.getAttribute('onclick') || '';
        if (onclick.includes(`showTab('${tabId}')`) || onclick.includes(`showTab("${tabId}")`)) {
          tab.classList.add('active');
          break;
        }
      }

      // Handle tab-specific logic via registry
      Object.keys(TAB_REGISTRY).forEach(key => {
        if (key !== tabId && TAB_REGISTRY[key].onHide) {
          TAB_REGISTRY[key].onHide();
        }
      });

      if (TAB_REGISTRY[tabId] && TAB_REGISTRY[tabId].onShow) {
        TAB_REGISTRY[tabId].onShow();
      }
    }

    async function uploadMCPConfig() {
      const fileInput = $("mcp-config-file");
      const statusEl = $("mcp-upload-status");

      if (!fileInput || !fileInput.files || !fileInput.files[0]) {
        if (statusEl) {
          safeSetText("mcp-upload-status", "Please select a file first");
          safeSetStyle("mcp-upload-status", "color", CSS_VARS.ERROR);
        }
        return;
      }

      const file = fileInput.files[0];
      const agentBase = getAgentBase();
      const token = getAuthToken();
      const headers = {};
      if (token) headers["Authorization"] = "Bearer " + token;

      if (statusEl) {
        safeSetText("mcp-upload-status", "Uploading and analyzing file...");
        safeSetStyle("mcp-upload-status", "color", CSS_VARS.ACCENT);
      }

      try {
        const formData = new FormData();
        formData.append("file", file);

        const response = await fetch(agentBase + "/admin/mcp/upload-config", {
          method: "POST",
          headers: headers,
          body: formData,
          credentials: "same-origin"
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ error: `HTTP ${response.status}` }));
          throw new Error(errorData.error || `HTTP ${response.status}`);
        }

        const result = await response.json();

        if (result.ok) {
          // Build detailed success message with clear formatting
          let message = `‚úì Successfully processed ${file.name}\n\n`;

          if (result.added && result.added.length > 0) {
            message += `‚úÖ Added ${result.added.length} server(s): ${result.added.join(", ")}\n`;
          }
          if (result.updated && result.updated.length > 0) {
            message += `üîÑ Updated ${result.updated.length} server(s): ${result.updated.join(", ")}\n`;
          }
          if (result.skipped && result.skipped.length > 0) {
            message += `‚è≠Ô∏è Skipped ${result.skipped.length} server(s): ${result.skipped.join(", ")}\n`;
          }
          if (result.total_servers) {
            message += `\nüìä Total MCP servers in config: ${result.total_servers}`;
          }
          if (result.warnings && result.warnings.length > 0) {
            message += `\n\n‚ö†Ô∏è Warnings:\n${result.warnings.map(w => `  ‚Ä¢ ${w}`).join("\n")}`;
          }

          if (statusEl) {
            safeSetText("mcp-upload-status", message);
            safeSetStyle("mcp-upload-status", "color", CSS_VARS.OK);
            safeSetStyle("mcp-upload-status", "white-space", "pre-wrap");
            safeSetStyle("mcp-upload-status", "line-height", "1.6");
          }

          // Clear file input
          if (fileInput) fileInput.value = "";

          // Auto-reload MCP servers to pick up changes
          setTimeout(() => reloadMCPServers(), 1000);
        } else {
          let errorMsg = `‚úó Upload failed: ${result.error || "Unknown error"}`;
          if (result.validation_errors && result.validation_errors.length > 0) {
            errorMsg += `\n\nValidation errors:\n${result.validation_errors.map(e => `  ‚Ä¢ ${e}`).join("\n")}`;
          }
          if (result.warnings && result.warnings.length > 0) {
            errorMsg += `\n\nWarnings:\n${result.warnings.map(w => `  ‚Ä¢ ${w}`).join("\n")}`;
          }
          if (statusEl) {
            safeSetText("mcp-upload-status", errorMsg);
            safeSetStyle("mcp-upload-status", "color", CSS_VARS.ERROR);
            safeSetStyle("mcp-upload-status", "white-space", "pre-wrap");
            safeSetStyle("mcp-upload-status", "line-height", "1.6");
          }
        }
      } catch (e) {
        const errorMsg = e.message || "Unknown error";
        if (statusEl) {
          safeSetText("mcp-upload-status", `‚úó Error: ${errorMsg}`);
          safeSetStyle("mcp-upload-status", "color", CSS_VARS.ERROR);
        }
        console.error("MCP config upload error:", e);
      }
    }

    async function reloadMCPServers() {
      const agentBase = getAgentBase();
      const statusEl = $("mcp-reload-status");
      if (!statusEl) return;

      safeSetText("mcp-reload-status", "Reloading MCP servers...");
      safeSetStyle("mcp-reload-status", "color", CSS_VARS.ACCENT);

      try {
        const headers = getHeaders(getAuthToken());
        const res = await postJson(agentBase + "/admin/reload-mcp", headers, {});
        if (res.ok) {
          safeSetText("mcp-reload-status", `‚úì Reloaded ${res.reloaded_count || 0} MCP server(s). Tools rediscovered.`);
          safeSetStyle("mcp-reload-status", "color", CSS_VARS.OK);
          setTimeout(() => refresh(), 2000);
        } else {
          safeSetText("mcp-reload-status", "Failed to reload: " + (res.error || "Unknown error"));
          safeSetStyle("mcp-reload-status", "color", CSS_VARS.ERROR);
        }
      } catch (e) {
        safeSetText("mcp-reload-status", "Error: " + e.message);
        safeSetStyle("mcp-reload-status", "color", CSS_VARS.ERROR);
      }
    }

    async function toggleBackgroundTask(taskName, enable) {
      const agentBase = getAgentBase();
      const action = enable ? "enable" : "disable";
      try {
        const headers = getHeaders(getAuthToken());
        const res = await postJson(agentBase + `/admin/background-tasks/${taskName}/${action}`, headers, {});
        if (res.ok) {
          setTimeout(() => refresh(), 500);
        } else {
          alert(`Failed to ${action} task: ${res.error || "Unknown error"}`);
        }
      } catch (e) {
        alert(`Error ${action}ing task: ${e.message}`);
      }
    }

    async function refreshDocumentation() {
      try {
        const agentBase = getAgentBase();
        const token = getAuthToken();
        const headers = getHeaders(token);

        const docsRes = await fetchJson(agentBase + "/admin/docs", headers).catch((e) => {
          console.warn("Documentation fetch failed:", e);
          return null;
        });

        const docsListEl = $("docs-list");
        if (!docsListEl) return;

        if (!docsRes || !docsRes.ok || !docsRes.docs) {
          docsListEl.innerHTML = '<div class="muted">Error loading documentation or no docs available.</div>';
          return;
        }

        const docs = docsRes.docs;
        const categories = docsRes.categories || {};

        // Group by category
        const grouped = {};
        for (const doc of docs) {
          const cat = doc.category || "other";
          if (!grouped[cat]) grouped[cat] = [];
          grouped[cat].push(doc);
        }

        // File directory style with categorization and sorting
        let html = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';

        // Category menu/filter
        const categoryList = Object.keys(grouped).sort();
        html += '<div style="margin-bottom: 0.75rem; display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">';
        html += '<span style="font-size: var(--font-sm); color: var(--muted);">Category:</span>';
        html += '<button onclick="filterDocsByCategory(null)" class="doc-category-btn active" style="padding: 0.3rem 0.6rem; font-size: var(--font-xs); border-radius: 0.25rem; border: 1px solid var(--border); background: var(--accent-soft); color: var(--accent); cursor: pointer;">All</button>';
        categoryList.forEach(cat => {
          const catName = categories[cat] || cat;
          html += `<button onclick="filterDocsByCategory('${cat}')" class="doc-category-btn" style="padding: 0.3rem 0.6rem; font-size: var(--font-xs); border-radius: 0.25rem; border: 1px solid var(--border); background: var(--panel); color: var(--text); cursor: pointer;">${catName}</button>`;
        });
        html += '</div>';

        // Sort options
        html += '<div style="margin-bottom: 0.75rem; display: flex; gap: 0.5rem; align-items: center;">';
        html += '<span style="font-size: var(--font-sm); color: var(--muted);">Sort:</span>';
        html += '<select id="doc-sort" onchange="sortDocumentation()" style="padding: 0.3rem 0.5rem; font-size: var(--font-xs); border-radius: 0.25rem; border: 1px solid var(--border); background: var(--panel); color: var(--text);">';
        html += '<option value="name">Name</option>';
        html += '<option value="size">Size</option>';
        html += '<option value="category">Category</option>';
        html += '</select>';
        html += '</div>';

        // File list (compact, directory style)
        for (const [category, categoryDocs] of Object.entries(grouped)) {
          const catName = categories[category] || category;
          html += `<div class="doc-category-section" data-category="${category}" style="margin-bottom: 0.75rem;">`;
          html += `<div style="font-weight: 500; margin-bottom: 0.4rem; font-size: var(--font-sm); color: var(--accent); padding: 0.3rem 0.5rem; background: rgba(79, 139, 255, 0.1); border-radius: 0.25rem;">${catName}</div>`;
          for (const doc of categoryDocs) {
            const sizeKB = (doc.size / 1024).toFixed(1);
            html += `
              <div 
                onclick="loadDocument('${doc.path}')" 
                class="doc-item" 
                data-category="${category}"
                data-name="${(doc.name || '').toLowerCase()}"
                data-size="${doc.size || 0}"
                style="padding: 0.4rem 0.5rem; margin-bottom: 0.15rem; cursor: pointer; border-radius: 0.2rem; border: 1px solid var(--border); transition: all 0.15s; display: flex; justify-content: space-between; align-items: center; font-size: var(--font-sm);"
                onmouseover="this.style.background='var(--accent-soft)'; this.style.borderColor='var(--accent)'"
                onmouseout="this.style.background=''; this.style.borderColor='var(--border)'"
                title="${doc.path}"
              >
                <span style="font-family: var(--mono);">${doc.name}</span>
                <span style="font-size: var(--font-xs); color: var(--muted);">${sizeKB} KB</span>
              </div>
            `;
          }
          html += `</div>`;
        }
        html += '</div>';

        docsListEl.innerHTML = html;
      } catch (e) {
        console.error("Error loading documentation:", e);
        const docsListEl = $("docs-list");
        if (docsListEl) {
          docsListEl.innerHTML = '<div class="muted">Error loading documentation: ' + (e.message || "Unknown error") + '</div>';
        }
      }
    }

    let currentDocCategory = null;
    let currentDocSort = 'name';

    function filterDocsByCategory(category) {
      currentDocCategory = category;
      document.querySelectorAll('.doc-category-btn').forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'var(--panel)';
        btn.style.color = 'var(--text)';
      });
      const clickedBtn = event?.target;
      if (clickedBtn && clickedBtn.classList.contains('doc-category-btn')) {
        clickedBtn.classList.add('active');
        clickedBtn.style.background = 'var(--accent-soft)';
        clickedBtn.style.color = 'var(--accent)';
      }

      document.querySelectorAll('.doc-category-section').forEach(section => {
        if (!category || section.dataset.category === category) {
          section.style.display = 'block';
        } else {
          section.style.display = 'none';
        }
      });
    }

    function sortDocumentation() {
      const sortSelect = $("doc-sort");
      if (!sortSelect) return;
      currentDocSort = sortSelect.value;

      document.querySelectorAll('.doc-category-section').forEach(section => {
        const items = Array.from(section.querySelectorAll('.doc-item'));
        items.sort((a, b) => {
          if (currentDocSort === 'name') {
            return (a.dataset.name || '').localeCompare(b.dataset.name || '');
          } else if (currentDocSort === 'size') {
            return (parseInt(b.dataset.size) || 0) - (parseInt(a.dataset.size) || 0);
          } else {
            return 0;
          }
        });
        items.forEach(item => section.appendChild(item));
      });
    }

    async function loadDocument(docPath) {
      try {
        const agentBase = getAgentBase();
        const token = getAuthToken();
        const headers = getHeaders(token);

        const docRes = await fetchJson(agentBase + `/admin/docs/${docPath}`, headers).catch((e) => {
          console.warn("Document fetch failed:", e);
          return null;
        });

        const docContentEl = $("doc-content");
        if (!docContentEl) return;

        if (!docRes || !docRes.ok || !docRes.content) {
          docContentEl.innerHTML = '<div class="muted">Error loading document or document not found.</div>';
          return;
        }

        // Highlight active doc in list
        document.querySelectorAll('.doc-item').forEach(el => {
          el.style.background = '';
          el.style.borderColor = 'var(--border)';
        });
        const clickedItem = event?.currentTarget || document.querySelector(`[onclick*="${docPath.replace(/'/g, "\\'")}"]`);
        if (clickedItem) {
          clickedItem.style.background = 'var(--accent-soft)';
          clickedItem.style.borderColor = 'var(--accent)';
        }

        // Convert markdown to HTML (simple conversion)
        let content = docRes.content;
        // Basic markdown to HTML conversion
        content = content
          .replace(/^# (.*$)/gim, '<h1>$1</h1>')
          .replace(/^## (.*$)/gim, '<h2>$1</h2>')
          .replace(/^### (.*$)/gim, '<h3>$1</h3>')
          .replace(/^#### (.*$)/gim, '<h4>$1</h4>')
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
          .replace(/\*(.*?)\*/g, '<em>$1</em>')
          .replace(/`([^`]+)`/g, '<code style="background: var(--bg); padding: 0.2rem 0.4rem; border-radius: 0.25rem;">$1</code>')
          .replace(/```([\s\S]*?)```/g, '<pre style="background: var(--bg); padding: 1rem; border-radius: 0.25rem; overflow-x: auto;"><code>$1</code></pre>')
          .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
          .replace(/\n\n/g, '</p><p>')
          .replace(/\n/g, '<br>');

        content = '<p>' + content + '</p>';

        docContentEl.innerHTML = `
          <div style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--border);">
            <strong style="font-size: 1.1rem;">${docPath}</strong>
          </div>
          <div style="white-space: pre-wrap; word-wrap: break-word;">${content}</div>
        `;
      } catch (e) {
        console.error("Error loading document:", e);
        const docContentEl = $("doc-content");
        if (docContentEl) {
          docContentEl.innerHTML = '<div class="muted">Error loading document: ' + (e.message || "Unknown error") + '</div>';
        }
      }
    }

    function filterDocumentation() {
      const searchTerm = ($("doc-search")?.value || "").toLowerCase();
      const docItems = document.querySelectorAll('.doc-item');
      docItems.forEach(item => {
        const text = item.textContent.toLowerCase();
        item.style.display = text.includes(searchTerm) ? 'block' : 'none';
      });
    }

    async function loadInfoContent() {
      // Legacy function - redirect to documentation
      await refreshDocumentation();
    }

    // Dashboard error tracking and learning
    function trackError(error, component, context) {
      try {
        const errorType = error instanceof TypeError ? "javascript_error" :
          error instanceof SyntaxError ? "javascript_error" :
            error.message?.includes("401") ? "auth_error" :
              error.message?.includes("timeout") ? "timeout" :
                error.message?.includes("network") ? "network_error" :
                  "unknown";

        const agentBase = getAgentBase();
        const headers = getHeaders(getAuthToken());

        fetch(agentBase + "/admin/dashboard/track-error", {
          method: "POST",
          headers: { ...headers, "Content-Type": "application/json" },
          credentials: "same-origin",
          body: JSON.stringify({
            error_type: errorType,
            error_message: error.message || String(error),
            error_stack: error.stack,
            url: window.location.href,
            component: component,
            context: context || {},
            request_id: lastRequestId
          })
        }).catch(e => {
          if (debugMode) console.warn("Failed to track error:", e);
        });
      } catch (e) {
        if (debugMode) console.warn("Error tracking failed:", e);
      }
    }

    function trackInteraction(action, target, success, durationMs, context) {
      try {
        const agentBase = getAgentBase();
        const headers = getHeaders(getAuthToken());

        fetch(agentBase + "/admin/dashboard/track-interaction", {
          method: "POST",
          headers: { ...headers, "Content-Type": "application/json" },
          credentials: "same-origin",
          body: JSON.stringify({
            action: action,
            target: target,
            success: success,
            duration_ms: durationMs,
            context: context || {}
          })
        }).catch(e => {
          if (debugMode) console.warn("Failed to track interaction:", e);
        });
      } catch (e) {
        // Silently fail
      }
    }

    // Global error handler to catch unhandled errors
    window.addEventListener("error", (event) => {
      trackError(event.error || event, "global", {
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno
      });
    });

    // Catch unhandled promise rejections
    window.addEventListener("unhandledrejection", (event) => {
      trackError(event.reason, "promise_rejection", {
        promise: event.promise
      });
    });

    // Toggle debug mode
    function toggleDebugMode() {
      debugMode = $("debug-mode-toggle").checked;
      localStorage.setItem("dashboard_debug_mode", debugMode ? "true" : "false");
      const trendsEl = $("debug-trends");
      if (trendsEl) trendsEl.style.display = debugMode ? "block" : "none";
      if (debugMode) {
        refreshDebugInfo();
        console.log("Debug mode enabled - verbose logging active");
      } else {
        console.log("Debug mode disabled");
      }
    }

    async function refreshDebugInfo() {
      try {
        const agentBase = getAgentBase();
        const token = getAuthToken();
        const headers = getHeaders(token);

        const insightsEl = $("debug-insights");
        const errorsEl = $("debug-errors");
        const patternsEl = $("debug-patterns");
        if (!insightsEl || !errorsEl || !patternsEl) return;

        insightsEl.textContent = "Loading insights...";
        errorsEl.textContent = "Loading errors...";
        patternsEl.textContent = "Loading patterns...";

        const [insightsRes, errorsRes, trendsRes] = await Promise.all([
          fetchJson(agentBase + "/admin/dashboard/insights", headers).catch(() => null),
          fetchJson(agentBase + "/admin/dashboard/errors?hours=24&limit=10", headers).catch(() => null),
          debugMode ? fetchJson(agentBase + "/admin/dashboard/errors?hours=24&limit=100", headers).catch(() => null) : Promise.resolve(null)
        ]);

        let insightsHtml = "";
        if (insightsRes && insightsRes.ok && insightsRes.insights) {
          const i = insightsRes.insights;
          insightsHtml += `<div style="margin-bottom:0.75rem;"><strong>Summary:</strong> ${i.total_errors || 0} errors, ${i.total_interactions || 0} interactions</div>`;

          if (i.most_problematic_components && i.most_problematic_components.length > 0) {
            insightsHtml += `<div style="margin-bottom:0.75rem;"><strong>Problem Areas:</strong><br>`;
            i.most_problematic_components.slice(0, 3).forEach(([component, count]) => {
              insightsHtml += `‚Ä¢ ${component}: ${count} errors<br>`;
            });
            insightsHtml += `</div>`;
          }

          if (i.top_error_patterns && i.top_error_patterns.length > 0) {
            insightsHtml += `<div><strong>Top Error Pattern:</strong><br>`;
            const pattern = i.top_error_patterns[0];
            const msg = (pattern.error_message || "Unknown").substring(0, 60);
            insightsHtml += `${msg} (${pattern.frequency || 1}x)<br>`;
            insightsHtml += `</div>`;
          }
        } else {
          insightsHtml = `<div class="muted">Unable to load insights. Check agent-runner connection.</div>`;
        }
        insightsEl.innerHTML = insightsHtml;

        let errorsHtml = "";
        if (errorsRes && errorsRes.ok && errorsRes.errors && errorsRes.errors.length > 0) {
          errorsRes.errors.slice(0, 10).forEach((err, idx) => {
            const time = new Date(err.timestamp * 1000).toLocaleTimeString();
            const msg = (err.error_message || "Unknown").substring(0, 50);
            const reqId = err.request_id ? ` [req:${err.request_id}]` : "";
            errorsHtml += `${idx + 1}. [${time}]${reqId} ${msg}<br>`;
          });
        } else {
          errorsHtml = '<div class="muted">No errors in the last 24 hours. ‚úì</div>';
        }
        errorsEl.innerHTML = errorsHtml;

        let patternsHtml = "";
        if (errorsRes && errorsRes.ok && errorsRes.patterns) {
          const patterns = errorsRes.patterns;
          if (patterns.length > 0) {
            patterns.slice(0, 5).forEach((pattern, idx) => {
              const time = new Date(pattern.timestamp * 1000).toLocaleString();
              const msg = (pattern.error_message || "Unknown").substring(0, 80);
              patternsHtml += `<div style="margin-bottom:0.75rem; padding:0.75rem; background:var(--bg); border-radius:0.25rem; border-left:3px solid var(--error);">`;
              patternsHtml += `<div style="font-weight:bold; color:var(--error);">Pattern ${idx + 1}: ${pattern.error_type || 'unknown'}</div>`;
              patternsHtml += `<div style="margin-top:0.25rem; color:var(--text);">${msg}</div>`;
              patternsHtml += `<div style="margin-top:0.5rem;"><strong>Frequency:</strong> ${pattern.frequency || 1} times</div>`;
              patternsHtml += `<div style="color:var(--muted); font-size:0.8rem; margin-top:0.25rem;">First seen: ${time}</div>`;
              patternsHtml += `</div>`;
            });
          } else {
            patternsHtml = '<div class="muted">No error patterns detected.</div>';
          }
        } else {
          patternsHtml = '<div class="muted">Unable to load patterns.</div>';
        }
        patternsEl.innerHTML = patternsHtml;

        // Render trend chart if debug mode is enabled
        if (debugMode && trendsRes && trendsRes.ok && trendsRes.errors) {
          renderErrorTrends(trendsRes.errors);
        }
      } catch (err) {
        console.error("Failed to refresh debug info:", err);
        trackError(err, "debug", {});
        const insightsEl = $("debug-insights");
        const errorsEl = $("debug-errors");
        const patternsEl = $("debug-patterns");
        if (insightsEl) insightsEl.innerHTML = '<div class="muted">Error loading debug info: ' + (err.message || "Unknown error") + '</div>';
        if (errorsEl) errorsEl.innerHTML = '<div class="muted">Error loading errors.</div>';
        if (patternsEl) patternsEl.innerHTML = '<div class="muted">Error loading patterns.</div>';
      }
    }

    function renderErrorTrends(errors) {
      const chartEl = $("trend-chart");
      if (!chartEl || !errors || errors.length === 0) {
        if (chartEl) chartEl.innerHTML = '<div class="muted">No error data for trends.</div>';
        return;
      }

      // Group errors by hour
      const now = Date.now() / 1000;
      const hours = 24;
      const buckets = Array(hours).fill(0);
      const labels = [];

      for (let i = 0; i < hours; i++) {
        const hourStart = now - (hours - i) * 3600;
        const hourEnd = hourStart + 3600;
        const hourErrors = errors.filter(e => e.timestamp >= hourStart && e.timestamp < hourEnd);
        buckets[i] = hourErrors.length;

        const date = new Date(hourStart * 1000);
        labels.push(date.getHours() + ":00");
      }

      const maxErrors = Math.max(...buckets, 1);
      const barHeight = 80;

      let chartHtml = '<div style="display:flex; align-items:flex-end; gap:2px; height:' + barHeight + 'px;">';
      buckets.forEach((count, idx) => {
        const height = maxErrors > 0 ? (count / maxErrors * barHeight) : 0;
        const color = count === 0 ? "rgba(148,163,184,0.2)" :
          count < 3 ? "rgba(250,204,21,0.6)" :
            count < 10 ? "rgba(250,204,21,0.8)" : "rgba(255,107,129,0.8)";
        chartHtml += `<div style="flex:1; background:${color}; height:${height}px; min-height:${count > 0 ? '2px' : '0'}; border-radius:1px 1px 0 0;" title="${labels[idx]}: ${count} errors"></div>`;
      });
      chartHtml += '</div>';
      chartHtml += '<div style="display:flex; justify-content:space-between; margin-top:0.25rem; font-size:0.7rem; color:var(--muted);">';
      chartHtml += `<span>${labels[0]}</span><span>Now</span>`;
      chartHtml += '</div>';

      chartEl.innerHTML = chartHtml;
    }

    // Display structured error responses from backend
    function displayStructuredError(error) {
      if (!error || typeof error !== 'object') {
        return `<div class="muted">Error: ${String(error)}</div>`;
      }

      // Check if it's a structured error response
      if (error.error && typeof error.error === 'object') {
        const err = error.error;
        let html = `<div style="padding: 1rem; background: rgba(239, 68, 68, 0.1); border: 1px solid var(--error); border-radius: 0.5rem; margin: 1rem 0;">`;
        html += `<div style="color: var(--error); font-weight: bold; margin-bottom: 0.5rem;">${escapeHtml(err.message || 'Error')}</div>`;

        if (err.code) {
          html += `<div style="font-size: 0.85rem; color: var(--muted); margin-bottom: 0.5rem;">Code: ${escapeHtml(err.code)}</div>`;
        }

        if (err.details && Object.keys(err.details).length > 0) {
          html += `<div style="font-size: 0.85rem; margin-top: 0.5rem;"><strong>Details:</strong><pre style="background: rgba(0,0,0,0.1); padding: 0.5rem; border-radius: 0.3rem; overflow-x: auto; font-size: 0.8rem;">${escapeHtml(JSON.stringify(err.details, null, 2))}</pre></div>`;
        }

        if (err.suggestions && Array.isArray(err.suggestions) && err.suggestions.length > 0) {
          html += `<div style="font-size: 0.85rem; margin-top: 0.5rem;"><strong>Suggestions:</strong><ul style="margin: 0.5rem 0; padding-left: 1.5rem;">`;
          err.suggestions.forEach(suggestion => {
            html += `<li>${escapeHtml(suggestion)}</li>`;
          });
          html += `</ul></div>`;
        }

        html += `</div>`;
        return html;
      }

      // Fallback for simple error objects
      if (error.error && typeof error.error === 'string') {
        return `<div class="muted">Error: ${escapeHtml(error.error)}</div>`;
      }

      return `<div class="muted">Error: ${escapeHtml(JSON.stringify(error))}</div>`;
    }


    // Store raw memory facts for filtering
    let rawMemoryFacts = [];

    // Task server status check function
    async function updateTaskServerStatus() {
      try {
        const agentBase = getAgentBase();
        const token = getAuthToken();
        const headers = getHeaders(token);
        const healthRes = await fetchJson(agentBase + "/admin/health", headers).catch((e) => {
          console.warn("Health check failed:", e);
          return null;
        });

        const taskStatusEl = $("task-server-status");
        const taskDetailsEl = $("task-server-details");
        if (!taskStatusEl || !taskDetailsEl) {
          return;
        }

        if (healthRes && healthRes.components && healthRes.components.task_server) {
          const taskStatus = healthRes.components.task_server;
          const status = taskStatus.status; // "healthy", "unhealthy", "unknown"

          if (status === "healthy") {
            taskStatusEl.textContent = "HEALTHY";
            taskStatusEl.style.color = CSS_VARS.OK;
            const enabled = taskStatus.enabled_tasks || 0;
            const running = taskStatus.running_tasks || 0;
            const total = taskStatus.total_tasks || 0;
            const model = taskStatus.task_model || "unknown";
            taskDetailsEl.innerHTML = `${enabled}/${total} enabled<br>${running} running<br>Model: ${model}`;
          } else {
            taskStatusEl.textContent = "UNHEALTHY";
            taskStatusEl.style.color = CSS_VARS.ERROR;
            taskDetailsEl.textContent = taskStatus.error || "Task server unavailable";
          }
        } else {
          taskStatusEl.textContent = "UNKNOWN";
          taskStatusEl.style.color = CSS_VARS.MUTED;
          taskDetailsEl.textContent = "Status unavailable";
        }
      } catch (e) {
        console.warn("Task server status check failed:", e);
        const taskStatusEl = $("task-server-status");
        const taskDetailsEl = $("task-server-details");
        if (taskStatusEl && taskDetailsEl) {
          taskStatusEl.textContent = "ERROR";
          taskStatusEl.style.color = CSS_VARS.ERROR;
          taskDetailsEl.textContent = "Check failed";
        }
      }
    }

    // Database status check function
    async function updateDatabaseStatus() {
      try {
        const agentBase = getAgentBase();
        const token = getAuthToken();
        const headers = getHeaders(token);
        // Use health endpoint instead of memory endpoint for database status
        const healthRes = await fetchJson(agentBase + "/admin/health", headers).catch((e) => {
          console.warn("Health check failed:", e);
          return null;
        });

        const dbStatusEl = $("database-status");
        const dbDetailsEl = $("database-details");
        if (!dbStatusEl || !dbDetailsEl) {
          console.warn("Database status elements not found");
          return;
        }

        if (healthRes && healthRes.components && healthRes.components.memory) {
          const memoryStatus = healthRes.components.memory;
          const status = memoryStatus.status; // "healthy", "unhealthy", "unknown"

          if (status === "healthy") {
            dbStatusEl.textContent = "Connected";
            dbStatusEl.style.color = "var(--ok)";
            // Parse the nested response structure
            const details = memoryStatus.details || {};
            const result = details.result || {};
            let connected = true;
            // Check if result has content array with JSON string
            if (result.content && Array.isArray(result.content)) {
              for (const item of result.content) {
                if (item.type === "text") {
                  try {
                    const parsed = JSON.parse(item.text);
                    connected = parsed.connected !== false;
                    break;
                  } catch (e) {
                    // Not JSON, continue
                  }
                }
              }
            } else if (result.connected !== undefined) {
              connected = result.connected !== false;
            }
            dbDetailsEl.textContent = `SurrealDB ${connected ? "Connected" : "Disconnected"}`;
          } else if (status === "unhealthy") {
            dbStatusEl.textContent = "Disconnected";
            dbStatusEl.style.color = "var(--error)";
            let errorMsg = memoryStatus.error || "Database unavailable";
            // Check if it's an MCP server failure
            if (errorMsg.includes("project-memory") || errorMsg.includes("MCP") || errorMsg.includes("mcp")) {
              errorMsg = "MCP server (project-memory) unavailable";
            }
            dbDetailsEl.textContent = errorMsg;
          } else {
            dbStatusEl.textContent = "Unknown";
            dbStatusEl.style.color = "var(--muted)";
            dbDetailsEl.textContent = memoryStatus.error || "Status unknown";
          }
        } else {
          dbStatusEl.textContent = "Unknown";
          dbStatusEl.style.color = "var(--muted)";
          dbDetailsEl.textContent = "Status check failed - agent-runner may be unavailable";
        }
      } catch (e) {
        console.warn("Database status update error:", e);
        const dbStatusEl = $("database-status");
        const dbDetailsEl = $("database-details");
        if (dbStatusEl && dbDetailsEl) {
          dbStatusEl.textContent = "Unknown";
          dbStatusEl.style.color = "var(--muted)";
          dbDetailsEl.textContent = "Status check failed: " + (e.message || "Unknown error");
        }
      }
    }

    async function refreshMemory() {
      const agentBase = getAgentBase();
      const token = getAuthToken();
      const headers = getHeaders(token);
      const memoryListEl = $("memory-list");

      try {
        // Show loading state
        if (memoryListEl) {
          memoryListEl.textContent = "Loading memory...";
        }

        const res = await fetchJson(agentBase + "/admin/memory", headers).catch((e) => {
          console.error("Memory fetch error:", e);
          return { ok: false, error: e.message || "Failed to connect to agent-runner" };
        });

        // Update memory health tag
        const healthTag = $("memory-health-tag");
        const healthText = $("memory-health-text");
        if (healthTag && healthText) {
          if (res && res.memory_health && res.memory_health.ok) {
            healthTag.className = "tag " + CLASS_NAMES.TAG_OK;
            safeSetText("memory-health-text", "DATABASE CONNECTED");
          } else {
            healthTag.className = "tag " + CLASS_NAMES.TAG_ERROR;
            const errorMsg = (res && res.memory_health && res.memory_health.error) ||
              (res && res.error) ||
              "DATABASE DISCONNECTED";
            safeSetText("memory-health-text", errorMsg);
          }
        }

        // Always show facts if database is connected, even if empty
        if (res && res.ok !== false) {
          rawMemoryFacts = res.facts || [];

          // Check if database is actually connected (not just a successful response)
          const dbConnected = res.memory_health?.ok === true || res.memory_health?.status === "healthy";

          if (rawMemoryFacts.length > 0) {
            renderMemoryFacts(rawMemoryFacts);
          } else if (dbConnected) {
            // Database connected but no facts yet - show helpful message
            if (memoryListEl) {
              memoryListEl.innerHTML = '<div class="muted" style="text-align:center; padding:2rem; line-height:1.6;"><div style="font-size:var(--font-md); margin-bottom:0.5rem;">Database Connected ‚úì</div><div>No facts stored yet. Facts will appear here as the agent learns and stores information.</div></div>';
            }
          } else {
            // Database not connected - show error
            if (memoryListEl) {
              memoryListEl.innerHTML = displayStructuredError(res);
            }
          }
        } else {
          // Handle structured error responses
          if (memoryListEl) {
            memoryListEl.innerHTML = displayStructuredError(res);
          }
          rawMemoryFacts = [];
        }
      } catch (e) {
        console.error("Memory refresh error:", e);
        if (memoryListEl) {
          memoryListEl.textContent = "Error loading memory: " + (e.message || "Unknown error");
        }
        rawMemoryFacts = [];

        // Update health tag to show error
        const healthTag = $("memory-health-tag");
        const healthText = $("memory-health-text");
        if (healthTag && healthText) {
          healthTag.className = "tag " + CLASS_NAMES.TAG_ERROR;
          let errorMsg = e.message || "Failed to load";
          if (errorMsg.includes("project-memory") || errorMsg.includes("MCP") || errorMsg.includes("mcp")) {
            errorMsg = "MCP server unavailable";
          }
          safeSetText("memory-health-text", "ERROR: " + errorMsg);
        }
      }
    }

    function renderMemoryFacts(facts) {
      if (!facts || facts.length === 0) {
        safeSetHTML("memory-list", '<div class="muted">No facts stored in memory.</div>');
        return;
      }

      const html = facts.map(f => {
        try {
          if (!f || typeof f !== 'object') return '';
          const factType = f.relation || 'unknown';
          const typeColor = factType.includes('has') || factType.includes('uses') ? CSS_VARS.ACCENT :
            factType.includes('error') || factType.includes('failed') ? CSS_VARS.ERROR :
              factType.includes('success') || factType.includes('ok') ? CSS_VARS.OK : CSS_VARS.MUTED;
          const entity = (f.entity || 'unknown').toString().replace(/['"]/g, '');
          const target = (f.target || 'unknown').toString().replace(/['"]/g, '');
          const factId = (f.fact_id || f.id || 'unknown').toString().replace(/['"]/g, '');
          const context = (f.context || '').toString().replace(/['"]/g, '');
          return `
            <div style="margin-bottom:0.75rem; padding:0.75rem; border-radius:0.5rem; border:1px solid var(--border); background:rgba(15,23,42,0.5); display:flex; justify-content:space-between; align-items:flex-start;">
              <div style="flex:1;">
                <div style="display:flex; align-items:center; gap:0.5rem; margin-bottom:0.3rem;">
                  <span class="tag" style="font-size:var(--font-xs); background:${typeColor}15; border-color:${typeColor}; color:${typeColor}; padding:0.1rem 0.4rem;">${factType}</span>
                  <span style="color:var(--text); font-weight:bold; font-size:var(--font-base);">${entity}</span>
                  <span style="color:var(--muted);">‚Üí</span>
                  <span style="color:var(--text); font-weight:bold; font-size:var(--font-base);">${target}</span>
                </div>
                <div style="font-size:var(--font-xs); color:var(--muted); margin-top:0.2rem;">
                  ID: ${factId}${context ? ` ‚Ä¢ Context: ${context}` : ''}
                </div>
              </div>
              <div style="display:flex; gap:0.4rem;">
                <button onclick="deleteFact('${factId}')" class="tag" style="cursor:pointer; background:rgba(255,107,129,0.1); border-color:var(--error); color:var(--error); padding:0.1rem 0.4rem;">Delete</button>
              </div>
            </div>
          `;
        } catch (e) {
          console.warn("Error rendering memory fact:", e, f);
          return '';
        }
      }).filter(h => h).join("");
      safeSetHTML("memory-list", html);
    }

    function filterMemoryFacts() {
      const searchTerm = ($("memory-search")?.value || "").toLowerCase();
      const filterType = $("memory-filter")?.value || "all";

      let filtered = rawMemoryFacts || [];

      if (searchTerm) {
        filtered = filtered.filter(f =>
          (f.entity || "").toLowerCase().includes(searchTerm) ||
          (f.relation || "").toLowerCase().includes(searchTerm) ||
          (f.target || "").toLowerCase().includes(searchTerm) ||
          (f.context || "").toLowerCase().includes(searchTerm)
        );
      }

      if (filterType === "entity") {
        // Group by entity
        const grouped = {};
        filtered.forEach(f => {
          const entity = f.entity || "unknown";
          if (!grouped[entity]) grouped[entity] = [];
          grouped[entity].push(f);
        });
        filtered = Object.values(grouped).flat();
      } else if (filterType === "relation") {
        // Group by relation
        const grouped = {};
        filtered.forEach(f => {
          const rel = f.relation || "unknown";
          if (!grouped[rel]) grouped[rel] = [];
          grouped[rel].push(f);
        });
        filtered = Object.values(grouped).flat();
      }

      renderMemoryFacts(filtered);
    }

    function exportMemory() {
      if (!rawMemoryFacts || rawMemoryFacts.length === 0) {
        alert("No memory facts to export.");
        return;
      }
      const dataStr = JSON.stringify(rawMemoryFacts, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `memory-export-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    async function deleteFact(id) {
      if (!confirm("Are you sure you want to delete this fact?")) return;

      const agentBase = getAgentBase();
      try {
        await postJson(agentBase + "/admin/memory/delete", { "Content-Type": "application/json" }, { fact_id: id });
        refreshMemory();
      } catch (e) {
        alert("Failed to delete fact: " + e.message);
      }
    }

    // indexArchitecture v2 - Fixed parsing 2025-01-17
    async function indexArchitecture() {
      const agentBase = getAgentBase();
      try {
        const res = await postJson(agentBase + "/admin/mcp/proxy", { "Content-Type": "application/json" }, {
          server: "project-memory",
          tool: "index_own_architecture",
          arguments: {}
        });

        // Parse nested MCP response: res.result.content[0].text contains JSON string
        let resultText = "‚úì Indexing completed successfully";
        let indexedCount = null;

        // Extract the JSON string from the nested structure
        if (res && res.result && res.result.content && Array.isArray(res.result.content)) {
          for (const item of res.result.content) {
            if (item && item.type === "text" && item.text) {
              try {
                // Parse the JSON string inside item.text
                const innerJson = JSON.parse(item.text);
                if (innerJson.ok && typeof innerJson.indexed_count === 'number') {
                  indexedCount = innerJson.indexed_count;
                  resultText = `‚úì Successfully indexed ${indexedCount} architectural facts`;
                  break;
                } else if (innerJson.ok) {
                  resultText = "‚úì Indexing completed successfully";
                  break;
                }
              } catch (parseErr) {
                // If JSON.parse fails, try regex to extract count
                const match = item.text.match(/"indexed_count"\s*:\s*(\d+)/);
                if (match) {
                  indexedCount = parseInt(match[1], 10);
                  resultText = `‚úì Successfully indexed ${indexedCount} architectural facts`;
                  break;
                }
              }
            }
          }
        }

        // Show clean message, never raw JSON
        alert(resultText);
        refreshMemory();
      } catch (e) {
        alert("‚úó Failed to index architecture: " + e.message);
        console.error("Index architecture error:", e);
      }
    }


    let rawSystemPrompt = "";
    let promptSectionsVisible = false;

    async function refreshSystemPrompt() {
      const agentBase = getAgentBase();
      const promptBox = $("current-system-prompt");
      if (!promptBox) return;

      safeSetText("current-system-prompt", "Loading prompt...");
      try {
        const res = await fetchJson(agentBase + "/admin/system-prompt", {});
        if (res.ok && res.prompt) {
          rawSystemPrompt = res.prompt;
          renderSystemPrompt(res.prompt);
        } else {
          safeSetText("current-system-prompt", "No prompt found or invalid response.");
          safeSetStyle("current-system-prompt", "color", CSS_VARS.WARN);
        }
      } catch (e) {
        safeSetText("current-system-prompt", "Error loading prompt: " + e.message);
        safeSetStyle("current-system-prompt", "color", CSS_VARS.ERROR);
      }
    }

    async function refreshModelServices() {
      const agentBase = getAgentBase();
      const routerBase = getRouterBase();
      const token = getAuthToken();
      const headers = getHeaders(token);
      const contentEl = $("model-services-content");

      if (!contentEl) return;

      try {
        contentEl.innerHTML = '<div class="muted">Loading model service mappings...</div>';

        // Fetch available models with timeout
        const modelsRes = await Promise.race([
          fetchJson(routerBase + "/v1/models", headers),
          new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), 5000))
        ]).catch(() => ({ data: [] }));
        const availableModels = modelsRes?.data || [];
        const modelIds = availableModels.map(m => m.id || "").filter(Boolean).sort();

        // Fetch agent-runner model info with timeout
        const agentRes = await Promise.race([
          fetchJson(agentBase + "/", headers),
          new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), 5000))
        ]).catch(() => ({ ok: false }));
        // The root endpoint now returns the model config directly
        const agentModels = agentRes || {};

        // Models are now included in the root endpoint response
        // Fallback values for backward compatibility
        let summarizationModel = agentModels.summarization_model || "Not configured";
        let fallbackModel = agentModels.fallback_model || "Not configured";
        if (agentModels.fallback_enabled === false) {
          fallbackModel += " (disabled)";
        }

        // Get current active LLM (from localStorage or agent model)
        // Note: We don't fetch metrics here to avoid blocking - metrics are fetched in main refresh()
        let activeLLM = localStorage.getItem("manuallySetActiveLLM") || null;
        // Fallback to agent model if not manually set
        if (!activeLLM && agentModels.agent_model) {
          activeLLM = agentModels.agent_model;
        }
        if (!activeLLM) {
          activeLLM = "Auto-detect";
        }

        // Build service-to-model mapping with selectors
        const services = [
          {
            id: "active",
            name: "Active LLM",
            description: "Currently active model for chat requests (router-level setting)",
            model: activeLLM,
            icon: "‚ö°",
            editable: true
          },
          {
            id: "agent",
            name: "Agent Model",
            description: "Main agent reasoning and tool-calling",
            model: agentModels.agent_model || "Not configured",
            icon: "üß†",
            editable: true
          },
          {
            id: "mcp",
            name: "MCP Model",
            description: "Model used for MCP tool calls (when MCP tools are present)",
            model: agentModels.mcp_model || agentModels.agent_model || "Not configured",
            icon: "üîß",
            editable: true
          },
          {
            id: "task",
            name: "Task Model",
            description: "Model for periodic background tasks",
            model: agentModels.task_model || "Not configured",
            icon: "‚öôÔ∏è",
            editable: true
          },
          {
            id: "summarization",
            name: "Summarization Model",
            description: "Model used for text summarization",
            model: agentModels.summarization_model || summarizationModel || "Not configured",
            icon: "üìù",
            editable: true
          },
          {
            id: "fallback",
            name: "Fallback Model",
            description: "Fallback model when primary model fails (if enabled)",
            model: agentModels.fallback_model || fallbackModel || "Not configured",
            icon: "üîÑ",
            editable: true
          },
          {
            id: "router",
            name: "Router Model",
            description: "Small, fast model for intelligent routing decisions",
            model: agentModels.router_model || "Not configured",
            icon: "üß≠",
            editable: false  // Router model is configured via config.yaml
          }
        ];

        // Build HTML with model selectors
        let html = '<div style="display: grid; gap: 1rem;">';
        services.forEach(service => {
          const modelStr = String(service.model || "");
          const isLocal = modelStr.startsWith("ollama:");
          const isRemote = modelStr.startsWith("openai:") || modelStr.startsWith("claude-") ||
            modelStr.startsWith("gemini-") || modelStr.startsWith("grok-") ||
            modelStr.startsWith("perplexity:");
          let modelClass = "";
          if (isLocal) modelClass = "tag-ok";
          else if (isRemote) modelClass = "tag-warn";

          // Build model selector dropdown
          let selectorHtml = "";
          if (service.editable && modelIds.length > 0) {
            selectorHtml = `
              <select id="model-select-${service.id}" 
                      style="margin-top:0.5rem; font-family:var(--mono); font-size:var(--font-sm); padding:0.4rem; border-radius:0.3rem; width:100%; background:var(--panel); color:var(--text); border:1px solid var(--border);"
                      onchange="changeServiceModel('${service.id}', this.value)">
                <option value="">Select model...</option>
                ${modelIds.map(id => `<option value="${escapeHtml(id)}" ${id === modelStr ? 'selected' : ''}>${escapeHtml(id)}</option>`).join('')}
              </select>
            `;
          }

          html += `
            <div style="padding: 1rem; background: rgba(15, 23, 42, 0.5); border-radius: 0.5rem; border: 1px solid var(--border);">
              <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                <span style="font-size: 1.2em;">${service.icon}</span>
                <strong style="font-size: var(--font-md);">${service.name}</strong>
              </div>
              <div class="muted" style="margin-bottom: 0.75rem; font-size: var(--font-sm);">
                ${service.description}
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: ${service.editable ? '0.5rem' : '0'};">
                <span class="tag ${modelClass}" style="font-family: var(--mono); font-size: var(--font-sm);">
                  ${escapeHtml(modelStr)}
                </span>
                ${isLocal ? '<span class="muted" style="font-size: var(--font-xs);">(Local)</span>' : ''}
                ${isRemote ? '<span class="muted" style="font-size: var(--font-xs);">(Remote)</span>' : ''}
              </div>
              ${selectorHtml}
            </div>
          `;
        });
        html += '</div>';

        contentEl.innerHTML = html;
      } catch (e) {
        const errorMsg = e?.message || "Unknown error";
        contentEl.innerHTML = `<div style="color: var(--status-error);">Error loading model services: ${errorMsg}</div>`;
        console.error("Model services refresh error:", e);
        // Track error for learning and troubleshooting
        // Note: This will be migrated to unified tracking system in backend
        trackError(e, "model-services", {
          function: "refreshModelServices",
          agent_base: agentBase,
          router_base: routerBase
        });
      }
    }

    // Make changeServiceModel globally accessible for inline onclick handlers
    window.changeServiceModel = async function (serviceId, modelId) {
      if (!modelId || modelId === "") {
        console.warn("changeServiceModel: No model selected");
        return;
      }

      const agentBase = getAgentBase();
      const routerBase = getRouterBase();
      const token = getAuthToken();
      const headers = { "Content-Type": "application/json", "Accept": "application/json" };
      if (token) headers["Authorization"] = "Bearer " + token;

      // Special handling for Active LLM (router-level setting)
      if (serviceId === "active") {
        try {
          console.log("Setting active model:", { routerBase, modelId, url: routerBase + "/admin/active-model" });
          // Update router's active_model
          const result = await postJson(routerBase + "/admin/active-model", headers, { model: modelId });
          if (result.ok) {
            // Store in localStorage for persistence
            localStorage.setItem("manuallySetActiveLLM", modelId);

            // If MCP toggle is enabled, also sync agent-runner's model
            const mcpToggle = $("mcp-toggle");
            if (mcpToggle && mcpToggle.checked) {
              try {
                await postJson(agentBase + "/admin/set-model", headers, { model: modelId });
              } catch (e) {
                console.warn("Failed to sync agent-runner model:", e);
              }
            }

            // Visual feedback: briefly highlight the model tag
            const selectEl = $("model-select-active");
            if (selectEl) {
              selectEl.style.borderColor = "var(--ok)";
              selectEl.style.boxShadow = "0 0 8px rgba(34, 197, 94, 0.3)";
              setTimeout(() => {
                selectEl.style.borderColor = "";
                selectEl.style.boxShadow = "";
              }, 1000);
            }

            // Refresh to show updated model
            refreshModelServices();
            refresh(); // Also refresh main dashboard
          } else {
            console.error(`Failed to update Active LLM: ${result.error || "Unknown error"}`);
          }
        } catch (e) {
          // Revert dropdown on error
          const selectEl = $("model-select-active");
          if (selectEl) {
            const storedModel = localStorage.getItem("manuallySetActiveLLM");
            if (storedModel) {
              selectEl.value = storedModel;
            } else {
              selectEl.value = "";
            }
          }
          const errorMsg = e.message || (e.response ? `HTTP ${e.response.status}` : "Unknown error");
          console.error(`Error updating Active LLM: ${errorMsg}`, e);
          trackError(e, "active-llm", { url: routerBase + "/admin/active-model", model: modelId });
        }
        return;
      }

      // Map service IDs to backend model field names
      const fieldMap = {
        "agent": "agent_model",
        "mcp": "mcp_model",
        "task": "task_model",
        "summarization": "summarization_model",
        "fallback": "fallback_model"
      };

      const fieldName = fieldMap[serviceId];
      if (!fieldName) {
        console.warn(`Model selection for ${serviceId} is not supported via API`);
        return;
      }

      // Store original value to revert on error
      const selectEl = $(`model-select-${serviceId}`);
      const originalValue = selectEl ? selectEl.value : null;

      try {
        // Use the standardized /admin/roles endpoint 
        const endpoint = "/admin/roles";
        console.log("Setting model:", { serviceId, fieldName, agentBase, endpoint, modelId, url: agentBase + endpoint });
        
        const payload = {
            updates: {
                [fieldName]: modelId
            }
        };

        const result = await postJson(agentBase + endpoint, headers, payload);
        if (result.ok) {
          // Visual feedback: briefly highlight the model tag
          if (selectEl) {
            selectEl.style.borderColor = "var(--ok)";
            selectEl.style.boxShadow = "0 0 8px rgba(34, 197, 94, 0.3)";
            setTimeout(() => {
              selectEl.style.borderColor = "";
              selectEl.style.boxShadow = "";
            }, 1000);
          }

          // Refresh to show updated model
          refreshModelServices();
          refresh(); // Also refresh main dashboard
        } else {
          // Revert dropdown on failure
          if (selectEl && originalValue !== null) {
            selectEl.value = originalValue;
          }
          console.error(`Failed to update ${serviceId} model: ${result.error || "Unknown error"}`);
        }
      } catch (e) {
        // Revert dropdown on error
        if (selectEl && originalValue !== null) {
          selectEl.value = originalValue;
        }
        const errorMsg = e.message || (e.response ? `HTTP ${e.response.status}` : "Unknown error");
        console.error(`Error updating ${serviceId} model: ${errorMsg}`, e);
        trackError(e, serviceId, { url: agentBase + endpoint, model: modelId });
      }
    };

    function renderSystemPrompt(prompt) {
      const promptBox = $("current-system-prompt");
      if (!promptBox) return;

      if (promptSectionsVisible) {
        // Parse prompt into sections
        const sections = {
          "Persona": prompt.match(/## Persona:.*?(?=##|$)/s)?.[0] || "",
          "Memories": prompt.match(/## Recalled Memories:.*?(?=##|$)/s)?.[0] || "",
          "System State": prompt.match(/## System State:.*?(?=##|$)/s)?.[0] || "",
          "Instructions": prompt.match(/## Instructions:.*?(?=##|$)/s)?.[0] || "",
          "Other": prompt
        };

        let html = "";
        Object.entries(sections).forEach(([title, content]) => {
          if (content && content.trim()) {
            html += `<div style="margin-bottom:1.5rem; padding:1rem; background:rgba(15,23,42,0.5); border-radius:0.5rem; border:1px solid var(--border);">
              <div style="font-weight:bold; color:var(--accent); margin-bottom:0.5rem; font-size:var(--font-md);">${title}</div>
              <div style="white-space:pre-wrap; font-family:var(--mono); font-size:var(--font-sm); line-height:1.6; color:var(--text);">${escapeHtml(content)}</div>
            </div>`;
          }
        });
        promptBox.innerHTML = html || `<div style="white-space:pre-wrap; font-family:var(--mono); font-size:var(--font-base);">${escapeHtml(prompt)}</div>`;
      } else {
        promptBox.innerHTML = `<div style="white-space:pre-wrap; font-family:var(--mono); font-size:var(--font-base); line-height:1.6;">${escapeHtml(prompt)}</div>`;
      }
      safeSetStyle("current-system-prompt", "color", CSS_VARS.TEXT);
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function togglePromptSections() {
      promptSectionsVisible = !promptSectionsVisible;
      const btn = $("toggle-sections-btn");
      if (btn) btn.textContent = promptSectionsVisible ? "Hide Sections" : "Show Sections";
      if (rawSystemPrompt) renderSystemPrompt(rawSystemPrompt);
    }

    function copySystemPrompt() {
      if (!rawSystemPrompt) {
        alert("No prompt loaded.");
        return;
      }
      navigator.clipboard.writeText(rawSystemPrompt).then(() => {
        alert("Prompt copied to clipboard!");
      }).catch(() => {
        alert("Failed to copy prompt.");
      });
    }

    // Store raw activity data for filtering
    let rawActivityData = [];

    function filterActivity() {
      // filterActivity now uses renderActivity which handles filtering internally
      renderActivity(rawActivityData || []);
    }

    function renderActivity(activities) {
      const searchTerm = ($("activity-search")?.value || "").toLowerCase();
      const filterType = $("activity-filter")?.value || "all";

      let filtered = activities || [];

      // Apply search filter
      if (searchTerm) {
        filtered = filtered.filter(a => {
          const model = (a.model || a.model_full || "").toLowerCase();
          const provider = (a.provider || "").toLowerCase();
          const status = String(a.status_code || "").toLowerCase();
          const requestId = (a.request_id || "").toLowerCase();
          return model.includes(searchTerm) || provider.includes(searchTerm) ||
            status.includes(searchTerm) || requestId.includes(searchTerm);
        });
      }

      // Apply status filter
      if (filterType === "success") {
        filtered = filtered.filter(a => {
          const success = a.success !== undefined ? a.success : (a.status_code >= 200 && a.status_code < 300);
          return success;
        });
      } else if (filterType === "error") {
        filtered = filtered.filter(a => {
          const success = a.success !== undefined ? a.success : (a.status_code >= 200 && a.status_code < 300);
          return !success;
        });
      }

      const container = $("recent-activity");
      if (!container) return;

      if (filtered.length === 0) {
        const emptyMsg = (activities || []).length === 0
          ? '<div class="muted">No requests yet.</div>'
          : '<div class="muted">No requests match the current filters.</div>';
        safeSetHTML("recent-activity", emptyMsg);
        return;
      }

      // Sort by timestamp (newest first)
      filtered.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

      const html = filtered.slice(0, 100).map(r => {
        try {
          if (!r || typeof r !== 'object') return '';
          const timestamp = r.timestamp || 0;
          const time = timestamp > 0 ? new Date(timestamp * 1000).toLocaleString() : 'Unknown';
          const success = r.success !== undefined ? r.success : (r.status_code >= 200 && r.status_code < 300);
          const status = r.status_code || (success ? 200 : 500);
          const statusColor = status >= 400 ? CSS_VARS.ERROR : (status >= 200 && status < 300) ? CSS_VARS.OK : CSS_VARS.MUTED;
          const model = r.model_full || (r.provider && r.model ? `${r.provider}:${r.model}` : r.model || 'unknown');
          const tokens = r.tokens ? (typeof r.tokens === 'object' ? (r.tokens.total || 0) : r.tokens) : 0;
          const tokensStr = tokens > 0 ? `${tokens} tokens` : "";
          const cost = r.cost_usd || 0.0;
          const costStr = cost > 0 ? `$${cost.toFixed(4)}` : "";
          const elapsed = r.elapsed_ms !== undefined ? `${r.elapsed_ms.toFixed(0)}ms` : '';

          return `<div style="margin-bottom:0.5rem; padding:0.6rem; border-radius:0.4rem; border:1px solid var(--border); background:rgba(15,23,42,0.3); transition:all 0.2s;" onmouseover="this.style.background='rgba(15,23,42,0.5)'; this.style.borderColor='var(--accent)'" onmouseout="this.style.background='rgba(15,23,42,0.3)'; this.style.borderColor='var(--border)'">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.3rem;">
              <div style="display:flex; align-items:center; gap:0.5rem;">
                <span style="color:${statusColor}; font-weight:bold; font-size:0.85rem;">${status}</span>
                <span style="color:var(--text); font-weight:500; font-family:var(--mono);">${model}</span>
              </div>
              <span style="color:var(--muted); font-size:0.75rem;">${time}</span>
            </div>
            <div style="display:flex; gap:0.75rem; font-size:0.75rem; color:var(--muted); flex-wrap:wrap;">
              ${elapsed ? `<span>‚è± ${elapsed}</span>` : ''}
              ${tokensStr ? `<span>üî¢ ${tokensStr}</span>` : ''}
              ${costStr ? `<span>üí∞ ${costStr}</span>` : ''}
              ${r.request_id ? `<span style="font-family:var(--mono);">ID: ${r.request_id.substring(0, 8)}</span>` : ''}
            </div>
          </div>`;
        } catch (e) {
          console.warn("Error rendering activity item:", e, r);
          return '';
        }
      }).filter(h => h).join("");
      safeSetHTML("recent-activity", html);
    }

    function exportActivity() {
      if (!rawActivityData || rawActivityData.length === 0) {
        alert("No activity data to export.");
        return;
      }
      const dataStr = JSON.stringify(rawActivityData, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `activity-export-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function renderModelPerformanceChart(metrics) {
      const container = $("model-performance-chart");
      if (!container || !metrics || !metrics.usage || !metrics.usage.by_model) {
        return;
      }

      const byModel = metrics.usage.by_model || {};
      const modelEntries = Object.entries(byModel)
        .sort((a, b) => (b[1].requests || 0) - (a[1].requests || 0))
        .slice(0, 10);

      if (modelEntries.length === 0) {
        safeSetHTML("model-performance-chart", '<div class="muted">No performance data yet.</div>');
        return;
      }

      const maxRequests = Math.max(...modelEntries.map(([_, stats]) => stats.requests || 0));
      const html = modelEntries.map(([model, stats]) => {
        const requests = stats.requests || 0;
        const width = maxRequests > 0 ? (requests / maxRequests * 100) : 0;
        const avgTime = stats.avg_time_ms || 0;
        const cost = stats.cost_usd || 0.0;
        const costStr = cost > 0 ? ` ‚Ä¢ $${cost.toFixed(4)}` : "";
        return `
          <div style="margin-bottom:1rem; padding:0.75rem; background:rgba(15,23,42,0.5); border-radius:0.5rem; border:1px solid var(--border);">
            <div style="display:flex; justify-content:space-between; margin-bottom:0.5rem;">
              <span style="font-weight:bold; color:var(--text); font-family:var(--mono);">${model}</span>
              <span style="color:var(--muted); font-size:var(--font-sm);">${requests} requests${costStr}</span>
            </div>
            <div style="width:100%; height:8px; background:rgba(148,163,184,0.1); border-radius:4px; overflow:hidden;">
              <div style="width:${width}%; height:100%; background:linear-gradient(90deg, ${CSS_VARS.ACCENT}, ${CSS_VARS.OK}); transition:width 0.3s;"></div>
            </div>
            <div style="margin-top:0.3rem; font-size:var(--font-xs); color:var(--muted);">
              Avg: ${avgTime.toFixed(0)}ms ‚Ä¢ Tokens: ${stats.total_tokens || 0}
            </div>
          </div>
        `;
      }).join("");
      safeSetHTML("model-performance-chart", html);
    }

    function renderToolPerformanceChart(toolMetrics) {
      const container = $("tool-performance-chart");
      if (!container || !toolMetrics || !toolMetrics.by_tool) {
        return;
      }

      const byTool = toolMetrics.by_tool || {};
      const toolEntries = Object.entries(byTool)
        .sort((a, b) => (b[1].calls || 0) - (a[1].calls || 0))
        .slice(0, 8);

      if (toolEntries.length === 0) {
        safeSetHTML("tool-performance-chart", '<div class="muted">No tool performance data yet.</div>');
        return;
      }

      const maxCalls = Math.max(...toolEntries.map(([_, stats]) => stats.calls || 0));
      const html = toolEntries.map(([tool, stats]) => {
        const calls = stats.calls || 0;
        const successRate = calls > 0 ? ((stats.successes / calls) * 100).toFixed(0) : "0";
        const width = maxCalls > 0 ? (calls / maxCalls * 100) : 0;
        const avgTime = stats.avg_time_ms || 0;
        return `
          <div style="margin-bottom:0.75rem; padding:0.5rem; background:rgba(15,23,42,0.3); border-radius:0.4rem;">
            <div style="display:flex; justify-content:space-between; margin-bottom:0.3rem;">
              <span style="font-weight:bold; color:var(--text); font-size:var(--font-sm);">${tool}</span>
              <span style="color:var(--muted); font-size:var(--font-xs);">${calls} calls ‚Ä¢ ${successRate}% success</span>
            </div>
            <div style="width:100%; height:6px; background:rgba(148,163,184,0.1); border-radius:3px; overflow:hidden;">
              <div style="width:${width}%; height:100%; background:${parseInt(successRate) >= 80 ? CSS_VARS.OK : parseInt(successRate) >= 50 ? CSS_VARS.WARN : CSS_VARS.ERROR}; transition:width 0.3s;"></div>
            </div>
            <div style="margin-top:0.2rem; font-size:var(--font-xs); color:var(--muted);">
              Avg: ${avgTime.toFixed(0)}ms
            </div>
          </div>
        `;
      }).join("");
      safeSetHTML("tool-performance-chart", html);
    }

    function formatTimeUntil(seconds) {
      if (seconds < 60) return `${Math.floor(seconds)}s`;
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
      if (seconds < 86400) return `${Math.floor(seconds / 3600)}h`;
      return `${Math.floor(seconds / 86400)}d`;
    }

    function formatDuration(seconds) {
      if (!seconds) return '';
      if (seconds < 60) return `${seconds.toFixed(1)}s`;
      if (seconds < 3600) return `${(seconds / 60).toFixed(1)}m`;
      return `${(seconds / 3600).toFixed(1)}h`;
    }

    function getPriorityColor(priority) {
      const colors = {
        'critical': 'var(--error)',
        'high': 'var(--warn)',
        'medium': 'var(--accent)',
        'low': 'var(--muted)',
        'background': 'var(--muted)'
      };
      return colors[priority] || 'var(--muted)';
    }

    function renderTaskCard(task) {
      const priorityColor = getPriorityColor(task.priority);
      const timeUntil = task.seconds_until !== null ? formatTimeUntil(task.seconds_until) : '';
      const nextRunTime = task.next_run ? new Date(task.next_run * 1000).toLocaleString() : '';
      const estimatedDuration = task.estimated_duration ? formatDuration(task.estimated_duration) : '';

      return `
        <div style="margin-bottom:0.75rem; padding:0.6rem; border-radius:0.4rem; background:rgba(15,23,42,0.3); border:1px solid rgba(148,163,184,0.2); border-left:3px solid ${priorityColor};">
          <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:0.4rem;">
            <div style="flex:1;">
              <div style="display:flex; align-items:center; gap:0.4rem; margin-bottom:0.2rem;">
                <strong style="color:var(--text); font-size:0.9rem;">${task.name}</strong>
                <span class="tag" style="font-size:0.6rem; padding:0.15rem 0.4rem; background:${priorityColor}20; border-color:${priorityColor}; color:${priorityColor};">
                  ${task.priority.toUpperCase()}
                </span>
              </div>
              ${task.description ? `<div style="font-size:0.75rem; color:var(--muted); margin-bottom:0.3rem;">${task.description}</div>` : ''}
            </div>
          </div>
          <div style="font-size:0.7rem; color:var(--muted); display:flex; flex-wrap:wrap; gap:0.5rem;">
            ${timeUntil ? `<span>‚è± ${timeUntil}</span>` : ''}
            ${nextRunTime ? `<span>üïê ${nextRunTime}</span>` : ''}
            ${estimatedDuration ? `<span>‚è≥ ~${estimatedDuration}</span>` : ''}
            ${task.type ? `<span>üìã ${task.type}</span>` : ''}
          </div>
        </div>
      `;
    }

    async function refreshTasks() {
      try {
        const agentBase = getAgentBase();
        const token = getAuthToken();
        const headers = getHeaders(token);

        const tasksRes = await fetchJson(agentBase + "/admin/background-tasks", headers).catch((e) => {
          console.warn("Background tasks fetch failed:", e);
          return null;
        });

        const tasksListEl = $("tasks-list");
        if (!tasksListEl) return;

        if (!tasksRes || !tasksRes.ok || !tasksRes.tasks) {
          tasksListEl.innerHTML = '<div class="muted">Error loading tasks or no tasks configured.</div>';
          return;
        }

        const tasks = tasksRes.tasks;
        const taskNames = Object.keys(tasks).sort();

        if (taskNames.length === 0) {
          tasksListEl.innerHTML = '<div class="muted">No tasks configured.</div>';
          return;
        }

        let html = '';
        for (const taskName of taskNames) {
          const task = tasks[taskName];
          const isRunning = task.running || false;
          const isEnabled = task.enabled !== false;
          const priority = task.priority || 'medium';
          const description = task.description || 'No description';
          const type = task.type || 'periodic';
          const runCount = task.run_count || 0;
          const errorCount = task.error_count || 0;
          const nextRun = task.next_run ? new Date(task.next_run * 1000).toLocaleString() : null;
          const secondsUntil = task.seconds_until_next;
          const lastError = task.last_error;
          const schedule = task.schedule; // Cron expression or schedule info
          const lastRun = task.last_run ? new Date(task.last_run * 1000).toLocaleString() : null;

          // Format next run time - be more intelligent about showing scheduling info
          let nextRunText = 'Not scheduled';
          let scheduleInfo = '';

          if (schedule) {
            scheduleInfo = `Schedule: ${schedule}`;
          }

          if (secondsUntil !== null && secondsUntil !== undefined && secondsUntil >= 0) {
            if (secondsUntil < 60) {
              nextRunText = `In ${Math.round(secondsUntil)}s`;
            } else if (secondsUntil < 3600) {
              nextRunText = `In ${Math.round(secondsUntil / 60)}m`;
            } else if (secondsUntil < 86400) {
              nextRunText = `In ${Math.round(secondsUntil / 3600)}h`;
            } else {
              nextRunText = `In ${Math.round(secondsUntil / 86400)}d`;
            }
            if (nextRun) {
              nextRunText += ` (${nextRun})`;
            }
          } else if (nextRun) {
            nextRunText = nextRun;
          } else if (schedule) {
            // Has schedule but no next_run calculated yet - show schedule
            nextRunText = `Scheduled: ${schedule}`;
          } else if (isEnabled && !isRunning) {
            // Enabled but no schedule - might be manual trigger only
            nextRunText = 'Manual trigger only';
          } else if (!isEnabled) {
            nextRunText = 'Disabled';
          }

          // Show last run if available
          if (lastRun && !isRunning) {
            scheduleInfo = scheduleInfo ? `${scheduleInfo} ‚Ä¢ Last: ${lastRun}` : `Last run: ${lastRun}`;
          }

          // Priority color
          const priorityColors = {
            critical: 'var(--error)',
            high: 'var(--warn)',
            medium: 'var(--accent)',
            low: 'var(--muted)',
            background: 'var(--muted)'
          };

          html += `
            <div class="card" style="border-left: 3px solid ${priorityColors[priority] || priorityColors.medium};">
              <div class="card-header" style="padding: 0.75rem;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <div>
                    <strong>${taskName}</strong>
                    <span class="tag" style="background: ${priorityColors[priority] || priorityColors.medium}; color: white; margin-left: 0.5rem; font-size: 0.75rem;">${priority}</span>
                    ${isRunning ? '<span class="tag" style="background: var(--accent); color: white; margin-left: 0.5rem; font-size: 0.75rem;">RUNNING</span>' : ''}
                    ${!isEnabled ? '<span class="tag" style="background: var(--muted); color: white; margin-left: 0.5rem; font-size: 0.75rem;">DISABLED</span>' : ''}
                  </div>
                  <button 
                    onclick="triggerTask('${taskName}')" 
                    class="tag" 
                    style="cursor:pointer; background:var(--accent-soft); border-color:var(--accent); ${isRunning ? 'opacity: 0.5; cursor: not-allowed;' : ''}"
                    ${isRunning ? 'disabled' : ''}
                    title="${isRunning ? 'Task is currently running' : 'Run task now'}"
                  >
                    ${isRunning ? '‚è≥ Running...' : '‚ñ∂ Run'}
                  </button>
                </div>
              </div>
              <div style="padding: 0.75rem; padding-top: 0;">
                <div class="muted" style="margin-bottom: 0.5rem; font-size: 0.85rem;">${description}</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.85rem;">
                  <div><strong>Type:</strong> ${type}</div>
                  <div><strong>Status:</strong> ${isRunning ? '<span style="color: var(--accent);">Running</span>' : isEnabled ? '<span style="color: var(--ok);">Enabled</span>' : '<span style="color: var(--muted);">Disabled</span>'}</div>
                  <div><strong>Next Run:</strong> ${nextRunText}</div>
                  <div><strong>Runs:</strong> ${runCount} ${errorCount > 0 ? `<span style="color: var(--error);">(${errorCount} errors)</span>` : ''}</div>
                </div>
                ${scheduleInfo ? `<div style="margin-top: 0.4rem; font-size: 0.8rem; color: var(--muted);">${scheduleInfo}</div>` : ''}
                ${lastError ? `<div style="margin-top: 0.5rem; padding: 0.5rem; background: var(--error-soft); border-left: 2px solid var(--error); font-size: 0.85rem; color: var(--error);"><strong>Last Error:</strong> ${lastError}</div>` : ''}
              </div>
            </div>
          `;
        }

        tasksListEl.innerHTML = html;
      } catch (e) {
        console.error("Error loading tasks:", e);
        const tasksListEl = $("tasks-list");
        if (tasksListEl) {
          tasksListEl.innerHTML = '<div class="muted">Error loading tasks: ' + (e.message || "Unknown error") + '</div>';
        }
      }
    }

    async function triggerTask(taskName) {
      try {
        const agentBase = getAgentBase();
        const token = getAuthToken();
        const headers = getHeaders(token);

        const result = await postJson(agentBase + `/admin/background-tasks/${taskName}/trigger`, headers, {});

        if (result.ok) {
          alert(`‚úì Task '${taskName}' triggered successfully`);
          // Refresh tasks list after a short delay to show running status
          setTimeout(() => refreshTasks(), 500);
        } else {
          alert(`‚úó Failed to trigger task: ${result.error || 'Unknown error'}`);
        }
      } catch (e) {
        alert(`‚úó Error triggering task: ${e.message || 'Unknown error'}`);
      }
    }

    async function refreshScheduler() {
      const agentBase = getAgentBase();
      const token = getAuthToken();
      const headers = getHeaders(token);
      try {
        const res = await fetchJson(agentBase + "/admin/background-tasks", headers);
        if (res && res.ok) {
          const upcoming = res.upcoming || {};

          // Next up (next minute)
          const nextUp = upcoming.next_up || [];
          safeSetText("next-up-count", nextUp.length.toString());
          safeSetHTML("next-up-tasks",
            nextUp.length > 0
              ? nextUp.map(renderTaskCard).join("")
              : '<div class="muted" style="text-align:center; padding:2rem;">No tasks in the next minute</div>'
          );

          // Next hour
          const nextHour = upcoming.next_hour || [];
          safeSetText("next-hour-count", nextHour.length.toString());
          safeSetHTML("next-hour-tasks",
            nextHour.length > 0
              ? nextHour.map(renderTaskCard).join("")
              : '<div class="muted" style="text-align:center; padding:2rem;">No tasks in the next hour</div>'
          );

          // Next week
          const nextWeek = upcoming.next_week || [];
          safeSetText("next-week-count", nextWeek.length.toString());
          safeSetHTML("next-week-tasks",
            nextWeek.length > 0
              ? nextWeek.map(renderTaskCard).join("")
              : '<div class="muted" style="text-align:center; padding:2rem;">No tasks this week</div>'
          );

          // Long term
          const longTerm = upcoming.long_term || [];
          safeSetText("long-term-count", longTerm.length.toString());
          safeSetHTML("long-term-tasks",
            longTerm.length > 0
              ? longTerm.map(renderTaskCard).join("")
              : '<div class="muted" style="text-align:center; padding:2rem;">No long-term tasks</div>'
          );
        } else {
          const errorMsg = res.message || 'No scheduler data available.';
          safeSetHTML("next-up-tasks", `<div class="muted">${errorMsg}</div>`);
          safeSetHTML("next-hour-tasks", `<div class="muted">${errorMsg}</div>`);
          safeSetHTML("next-week-tasks", `<div class="muted">${errorMsg}</div>`);
          safeSetHTML("long-term-tasks", `<div class="muted">${errorMsg}</div>`);
        }
      } catch (e) {
        console.error("Error loading scheduler:", e);
        const errorMsg = `Error loading scheduler: ${e.message || "Unknown error"}`;
        safeSetHTML("next-up-tasks", `<div class="muted">${errorMsg}</div>`);
        safeSetHTML("next-hour-tasks", `<div class="muted">${errorMsg}</div>`);
        safeSetHTML("next-week-tasks", `<div class="muted">${errorMsg}</div>`);
        safeSetHTML("long-term-tasks", `<div class="muted">${errorMsg}</div>`);
      }
    }

    // Alias for backward compatibility
    async function refreshBackgroundTasks() {
      await refreshScheduler();
    }

    async function refreshTaskHistory() {
      const agentBase = getAgentBase();
      try {
        // Background tasks endpoint doesn't have history - show message
        safeSetHTML("task-history-list", '<div class="muted">Task execution history is not available. Check individual task status above for last run times.</div>');
      } catch (e) {
        safeSetHTML("task-history-list", `<div class="muted">Error loading history: ${e.message}</div>`);
      }
    }

    function filterManual() {
      const searchTerm = ($("manual-search")?.value || "").toLowerCase();
      const contentEl = $("info-content");
      if (!contentEl) return;

      const text = contentEl.textContent || "";
      if (!searchTerm) {
        contentEl.innerHTML = escapeHtml(text);
        return;
      }

      // Highlight search term
      const regex = new RegExp(`(${searchTerm})`, 'gi');
      const highlighted = text.replace(regex, '<mark style="background:var(--warn); color:var(--bg); padding:0.1rem 0.2rem; border-radius:0.2rem;">$1</mark>');
      contentEl.innerHTML = highlighted;
    }

    function formatUptime(seconds) {
      const d = Math.floor(seconds / (3600 * 24));
      const h = Math.floor((seconds % (3600 * 24)) / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = Math.floor(seconds % 60);

      const parts = [];
      if (d > 0) parts.push(`${d}d`);
      if (h > 0) parts.push(`${h}h`);
      if (m > 0) parts.push(`${m}m`);
      if (parts.length === 0) parts.push(`${s}s`);

      return parts.join(" ");
    }

    function setStatus(okRouter, okAgent) {
      const tag = $("status-tag");
      const text = $("status-text");
      if (!tag || !text) return;

      if (okRouter && okAgent) {
        tag.classList.remove(CLASS_NAMES.TAG_ERROR, CLASS_NAMES.TAG_WARN);
        tag.classList.add(CLASS_NAMES.TAG_OK);
        safeSetText("status-text", "All services healthy");
      } else if (okRouter || okAgent) {
        tag.classList.remove(CLASS_NAMES.TAG_ERROR, CLASS_NAMES.TAG_OK);
        tag.classList.add(CLASS_NAMES.TAG_WARN);
        safeSetText("status-text", okRouter ? "Router only" : "Agent-runner only");
      } else {
        tag.classList.remove(CLASS_NAMES.TAG_OK, CLASS_NAMES.TAG_WARN);
        tag.classList.add(CLASS_NAMES.TAG_ERROR);
        safeSetText("status-text", "Offline");
      }
    }

    function shortList(arr, max = 4) {
      if (!Array.isArray(arr) || arr.length === 0) return "none";
      if (arr.length <= max) return arr.join(", ");
      return arr.slice(0, max).join(", ") + ` ‚Ä¶ (+${arr.length - max} more)`;
    }

    async function fetchJson(url, headers) {
      // Include credentials to send HTTP-only cookies (secure authentication)
      const startTime = performance.now();
      try {
        const res = await fetch(url, {
          headers,
          credentials: "same-origin"  // Send cookies automatically
        });

        // Capture request ID from response header
        const requestId = res.headers.get("X-Request-ID");
        if (requestId) {
          lastRequestId = requestId;
          if (debugMode) console.log(`[${requestId}] ${url}`);
        }

        const duration = performance.now() - startTime;

        // Track API interactions
        const component = url.split("/").pop() || "unknown";
        trackInteraction("api_call", component, res.ok, duration, {
          url: url,
          status: res.status,
          request_id: requestId
        });

        if (!res.ok) {
          const error = new Error(`HTTP ${res.status}`);
          trackError(error, component, { url: url, status: res.status, request_id: requestId });
          throw error;
        }

        if (debugMode && duration > 1000) {
          console.warn(`Slow API call: ${url} took ${duration.toFixed(0)}ms`);
        }

        return res.json();
      } catch (e) {
        const duration = performance.now() - startTime;
        const component = url.split("/").pop() || "unknown";
        trackError(e, component, { url: url, duration_ms: duration, request_id: lastRequestId });
        throw e;
      }
    }

    async function postJson(url, headers, bodyObj) {
      // Include credentials to send HTTP-only cookies (secure authentication)
      const res = await fetch(url, {
        method: "POST",
        headers,
        body: JSON.stringify(bodyObj || {}),
        credentials: "same-origin"  // Send cookies automatically
      });
      if (!res.ok) {
        // Try to get error message from response body
        let errorMsg = `HTTP ${res.status}`;
        try {
          const errorBody = await res.json();
          if (errorBody.detail) {
            errorMsg = typeof errorBody.detail === 'string' ? errorBody.detail : JSON.stringify(errorBody.detail);
          } else if (errorBody.error) {
            errorMsg = errorBody.error;
          } else if (errorBody.message) {
            errorMsg = errorBody.message;
          }
        } catch (e) {
          // If JSON parsing fails, use status text
          errorMsg = res.statusText || `HTTP ${res.status}`;
        }
        const error = new Error(errorMsg);
        error.response = res; // Attach response for debugging
        throw error;
      }
      return res.json();
    }

    // ============================================================================
    // STATE MANAGEMENT
    // ============================================================================
    let manuallySetActiveLLM = null;
    let manuallySetAgentModel = null;
    let mcpToolAccessEnabled = false;
    let refreshSuspended = false;
    let refreshIntervalId = null;

    // ============================================================================
    // REFRESH HELPER FUNCTIONS
    // ============================================================================

    /**
     * Update health bar with issues
     */
    function updateHealthBar(routerRoot, agentRoot, systemStatus) {
      const healthIssues = [];
      if (!routerRoot) healthIssues.push({ type: 'error', msg: 'Router service is DOWN' });
      if (!agentRoot) healthIssues.push({ type: 'error', msg: 'Agent-runner service is DOWN' });

      if (agentRoot) {
        // Health check issues are already shown via individual component statuses
        // No need to duplicate them here

        const mcpErrors = agentRoot.mcp_initialization_errors || {};
        const mcpDiagnoses = agentRoot.mcp_diagnoses || {};

        Object.entries(mcpErrors).forEach(([server, err]) => {
          const diagnosis = mcpDiagnoses[server] ? `<br><small style="opacity:0.8;">Diagnosis: ${mcpDiagnoses[server]}</small>` : '';
          healthIssues.push({ type: 'error', msg: `MCP <strong>${server}</strong> initialization failed: ${err}${diagnosis}` });
        });

        if (agentRoot.circuit_breaker && agentRoot.circuit_breaker.disabled_servers.length > 0) {
          agentRoot.circuit_breaker.disabled_servers.forEach(server => {
            const diagnosis = mcpDiagnoses[server] ? `<br><small style="opacity:0.8;">Diagnosis: ${mcpDiagnoses[server]}</small>` : '';
            healthIssues.push({ type: 'warn', msg: `MCP <strong>${server}</strong> disabled (circuit breaker)${diagnosis}` });
          });
        }
      }

      const healthBar = $("health-bar");
      const healthList = $("health-message-list");
      if (!healthBar || !healthList) return;

      if (healthIssues.length > 0) {
        healthBar.style.display = "flex";
        healthBar.className = "health-bar " + (healthIssues.some(i => i.type === 'error') ? "has-errors" : "has-issues");
        healthList.innerHTML = healthIssues.map(i => `
          <div class="health-item ${i.type}">
            <span>${i.type === 'error' ? '‚úó' : '‚ö†'}</span>
            <span>${i.msg}</span>
          </div>
        `).join("");
      } else {
        healthBar.style.display = "none";
      }
    }

    /**
     * Update router status display
     */
    function updateRouterStatus(routerRoot) {
      if (routerRoot && routerRoot.ok) {
        safeSetText("router-ok", "OK");
        safeToggleClass("router-ok", CLASS_NAMES.KPI_VALUE_STRONG, true);
        const uptimeStr = formatUptime(Math.round(routerRoot.uptime_s || 0));
        safeSetText("router-version", `v${routerRoot.version} ‚Ä¢ ${uptimeStr}`);
        safeSetText("providers-count", (routerRoot.providers_loaded || []).length || "0");
        safeSetText("providers-list", shortList(routerRoot.providers_loaded || []));
        safeSetText("auth-info", routerRoot.auth_enabled ? "Token required" : "No token");
        safeSetText("concurrency-info", routerRoot.max_concurrency
          ? `Max in-flight: ${routerRoot.max_concurrency}`
          : "Unlimited in-flight");
        return true;
      } else {
        safeSetText("router-ok", "DOWN");
        safeToggleClass("router-ok", CLASS_NAMES.KPI_VALUE_STRONG, false);
        safeSetText("router-version", "");
        safeSetText("providers-count", "‚Äî");
        safeSetText("providers-list", "‚Äî");
        safeSetText("auth-info", "Unknown");
        safeSetText("concurrency-info", "");
        return false;
      }
    }

    /**
     * Update agent-runner status display
     */
    function updateAgentStatus(agentRoot) {
      if (agentRoot && agentRoot.ok) {
        safeSetText("agent-ok", "OK");
        safeToggleClass("agent-ok", CLASS_NAMES.KPI_VALUE_STRONG, true);
        const uptimeStr = formatUptime(Math.round(agentRoot.uptime_s || 0));
        const agentModel = agentRoot.models?.agent_model || agentRoot.agent_model || agentRoot.model || "unknown";
        safeSetText("agent-model", `${agentModel} ‚Ä¢ ${uptimeStr}`);
        safeSetStyle("start-agent-btn", "display", "none");
        safeSetStyle("stop-agent-btn", "display", "inline-flex");
        safeSetStyle("restart-agent-btn", "display", "inline-flex");
        safeSetStyle("restart-router-btn", "display", "inline-flex");
        safeSetStyle("restart-all-btn", "display", "inline-flex");
        return true;
      } else {
        safeSetText("agent-ok", "DOWN");
        safeToggleClass("agent-ok", CLASS_NAMES.KPI_VALUE_STRONG, false);
        safeSetText("agent-model", "");
        safeSetStyle("start-agent-btn", "display", "inline-flex");
        safeSetStyle("stop-agent-btn", "display", "none");
        safeSetStyle("restart-agent-btn", "display", "none");
        safeSetStyle("restart-router-btn", "display", "inline-flex");
        safeSetStyle("restart-all-btn", "display", "inline-flex");
        return false;
      }
    }

    let lastRefreshTime = 0;
    const MIN_REFRESH_INTERVAL = 2000; // Minimum 2 seconds between refreshes

    async function refresh() {
      // Track refresh start time for performance monitoring (before any early returns)
      const refreshStartTime = performance.now();

      // Don't refresh if suspended (e.g., during model changes)
      if (refreshSuspended) {
        return;
      }

      // Throttle refreshes to prevent excessive calls
      const now = Date.now();
      if (now - lastRefreshTime < MIN_REFRESH_INTERVAL) {
        return;
      }
      lastRefreshTime = now;

      // Safety check: ensure critical elements exist
      if (!$("router-base")) {
        return;
      }

      // Reload manually set Active LLM from localStorage at start of each refresh
      // This ensures it's always current, even if localStorage was updated elsewhere
      const storedActiveLLM = localStorage.getItem("manuallySetActiveLLM");
      if (storedActiveLLM !== manuallySetActiveLLM) {
        manuallySetActiveLLM = storedActiveLLM || null;
      }

      const base = getRouterBase();
      // Ensure token is loaded from localStorage if input field is empty
      const tokenEl = $("auth-token");
      if (tokenEl && !tokenEl.value.trim()) {
        const savedToken = localStorage.getItem("router_auth_token");
        if (savedToken) {
          tokenEl.value = savedToken;
        }
      }
      const token = getAuthToken();
      const showAll = $("show-all-models-check")?.checked || false;
      const headers = getHeaders(token);
      const agentBase = getAgentBase(base);

      const refreshBtn = $("refresh-btn");
      if (refreshBtn) refreshBtn.disabled = true;
      safeSetText("status-text", "Refreshing‚Ä¶");

      let routerOk = false;
      let agentOk = false;

      try {
        const [routerRoot, agentRoot, models, metrics, agentMetrics, systemStatus] = await Promise.all([
          fetchJson(base + "/", headers).catch((e) => { console.warn("Router root failed:", e); return null; }),
          fetchJson(agentBase + "/", headers).catch((e) => { console.warn("Agent root failed:", e); return null; }),
          fetchJson(base + "/v1/models" + (showAll ? "?all=true" : ""), headers).catch((e) => {
            // Check if it's a 401 error - auth required
            if (e && e.message && e.message.includes("401")) {
              console.warn("Models failed: Authentication required (401)");
            } else {
              console.warn("Models failed:", e);
            }
            return null;
          }),
          fetchJson(base + "/metrics", headers).catch((e) => { console.warn("Router metrics failed:", e); return null; }),
          fetchJson(agentBase + "/metrics", headers).catch((e) => { console.warn("Agent metrics failed:", e); return null; }),
          fetchJson(agentBase + "/admin/system-status", headers).catch((e) => { console.warn("System status failed:", e); return null; }),
        ]);

        // Check if auth is required but failing
        // Note: With HTTP-only cookies, JavaScript can't check if cookie is set (by design for security)
        // So we check if auth is enabled AND we're getting 401 errors
        const authWarningEl = $("auth-token-warning");
        const has401Error = !models && routerRoot && routerRoot.auth_enabled;
        const currentToken = getAuthToken(); // For manual bearer token entry (fallback)

        if (routerRoot && routerRoot.auth_enabled) {
          // Auth is enabled - check if we're getting 401 errors
          if (has401Error && !currentToken) {
            // Getting 401 errors and no bearer token set
            // This could mean cookie isn't working or browser needs refresh
            if (authWarningEl) {
              authWarningEl.style.display = "block";
              authWarningEl.innerHTML = '<strong>‚ö†Ô∏è Authentication Required:</strong> Router authentication is enabled. If you see 401 errors, try refreshing the page (Cmd+Shift+R / Ctrl+Shift+R) to receive the authentication cookie. Alternatively, enter your auth token above for bearer token authentication.';
            }
          } else {
            // Either no 401 errors (cookie is working) or bearer token is set
            if (authWarningEl) {
              authWarningEl.style.display = "none";
            }
          }
        } else if (authWarningEl) {
          // Auth not enabled - hide warning
          authWarningEl.style.display = "none";
        }

        // Update MCP toggle state from router metrics
        if (metrics && metrics.ok && typeof metrics.mcp_tool_access_enabled === "boolean") {
          mcpToolAccessEnabled = metrics.mcp_tool_access_enabled;
          const mcpToggle = $("mcp-toggle");
          if (mcpToggle) {
            mcpToggle.checked = mcpToolAccessEnabled;
          }
          updateMCPToggleUI();
        }

        // Update router's active_model from metrics (if available)
        if (metrics && metrics.ok && metrics.active_model) {
          // Sync router's active_model with dashboard's manuallySetActiveLLM if not set
          if (!manuallySetActiveLLM && metrics.active_model) {
            manuallySetActiveLLM = metrics.active_model;
            localStorage.setItem("manuallySetActiveLLM", metrics.active_model);
          }
        }

        // Update database status from memory health (if available)
        // Do this asynchronously so it doesn't block the main refresh
        updateDatabaseStatus();
        updateTaskServerStatus();

        // Update health bar
        updateHealthBar(routerRoot, agentRoot, systemStatus);

        // Update router status
        routerOk = updateRouterStatus(routerRoot);
        if (routerRoot && routerRoot.ok) {
          window.routerNumCtx = routerRoot.ollama_num_ctx;
        }

        // Update agent status
        agentOk = updateAgentStatus(agentRoot);

        // Debug: Log agentRoot if it exists but doesn't have ok
        if (agentRoot && !agentRoot.ok) {
          console.warn("Agent root response received but not OK:", agentRoot);
        } else if (!agentRoot) {
          console.warn("Agent root request failed - agent-runner may not be responding");
        }

        if (agentRoot && agentRoot.ok) {

          const tools = agentRoot.tools || [];
          const mcpTools = agentRoot.mcp_tools || [];
          const mcpServers = agentRoot.mcp_servers || [];
          const mcpErrors = agentRoot.mcp_initialization_errors || {};
          // tools-summary removed - not useful in Overview tab

          const badges = [];
          (mcpServers || []).forEach((name) => {
            const span = document.createElement("span");
            span.className = "badge";
            const err = mcpErrors[name];
            if (err) {
              span.style.border = `1px solid ${CSS_VARS.ERROR}`;
              span.style.color = CSS_VARS.ERROR; // Using consistent error color
              span.textContent = `MCP: ${name} (Error: ${err})`;
              span.title = err;
            } else {
              span.textContent = `MCP: ${name}`;
            }
            badges.push(span);
          });
          const badgeContainer = $("mcp-badges");
          if (badgeContainer) {
            badgeContainer.innerHTML = "";
            if (badges.length) {
              badges.forEach((b) => badgeContainer.appendChild(b));
            } else {
              badgeContainer.innerHTML = '<span class="muted" style="font-size:0.78rem;">No MCP servers configured (set MCP_SERVERS in agent_runner.env).</span>';
            }
          }

          // Circuit breaker status
          const cb = agentRoot.circuit_breaker || {};
          const disabled = cb.disabled_servers || [];
          const failures = cb.failure_counts || {};

          // Display disabled servers card (fetch detailed status)
          const disabledCard = $("disabled-mcp-servers-card");
          const disabledList = $("disabled-servers-list");
          if (disabledCard && disabledList) {
            if (disabled.length > 0) {
              disabledList.innerHTML = '<div class="muted" style="padding:0.5rem; text-align:center;">Loading details...</div>';

              // Fetch detailed circuit breaker status
              (async () => {
                try {
                  const agentBase = getAgentBase();
                  const token = getAuthToken();
                  const headers = {};
                  if (token) headers["Authorization"] = "Bearer " + token;

                  const res = await fetch(`${agentBase}/admin/circuit-breaker/status`, {
                    headers: headers,
                    credentials: "same-origin"
                  });

                  if (res.ok) {
                    const cbStatus = await res.json();
                    const circuitBreakers = cbStatus.circuit_breakers || {};

                    disabledList.innerHTML = "";

                    disabled.forEach((server) => {
                      const cb = circuitBreakers[server] || {};
                      const failureCount = cb.failures || failures[server] || 0;
                      const timeUntil = cb.time_until_recovery_seconds || 0;
                      const message = cb.message || `Disabled due to ${failureCount} failure${failureCount !== 1 ? 's' : ''}`;

                      const serverDiv = document.createElement("div");
                      serverDiv.style.cssText = "padding:0.75rem; margin-bottom:0.5rem; background:var(--state-down-bg); border:1px solid var(--error); border-radius:0.4rem; display:flex; justify-content:space-between; align-items:center;";

                      const serverInfo = document.createElement("div");
                      serverInfo.style.cssText = "flex:1;";

                      const serverName = document.createElement("div");
                      serverName.style.cssText = "font-weight:bold; color:var(--error); margin-bottom:0.25rem;";
                      serverName.textContent = server;

                      const failureInfo = document.createElement("div");
                      failureInfo.style.cssText = "font-size:var(--font-sm); color:var(--muted);";

                      if (timeUntil > 0) {
                        const minutes = Math.floor(timeUntil / 60);
                        const seconds = Math.floor(timeUntil % 60);
                        failureInfo.textContent = `${message}. Retry in ${minutes}m ${seconds}s`;
                      } else {
                        failureInfo.textContent = message;
                      }

                      serverInfo.appendChild(serverName);
                      serverInfo.appendChild(failureInfo);

                      const resetBtn = document.createElement("button");
                      resetBtn.textContent = "Reset";
                      resetBtn.className = "tag";
                      resetBtn.style.cssText = "cursor:pointer; background:var(--accent-soft); border-color:var(--accent); padding:0.3rem 0.6rem; font-size:var(--font-sm);";
                      resetBtn.onclick = async () => {
                        try {
                          const agentBase = getAgentBase();
                          const token = getAuthToken();
                          const headers = { "Content-Type": "application/json" };
                          if (token) headers["Authorization"] = "Bearer " + token;

                          const res = await fetch(`${agentBase}/admin/circuit-breaker/reset`, {
                            method: "POST",
                            headers: headers,
                            body: JSON.stringify({ server: server }),
                            credentials: "same-origin"
                          });

                          if (res.ok) {
                            console.log(`Circuit breaker reset for ${server}`);
                            refresh(); // Refresh dashboard to update status
                          } else {
                            const error = await res.json().catch(() => ({ error: `HTTP ${res.status}` }));
                            console.error(`Failed to reset circuit breaker: ${error.error || res.status}`);
                          }
                        } catch (e) {
                          console.error(`Error resetting circuit breaker: ${e.message}`);
                        }
                      };

                      serverDiv.appendChild(serverInfo);
                      serverDiv.appendChild(resetBtn);
                      disabledList.appendChild(serverDiv);
                    });
                  } else {
                    // Fallback to basic display if detailed status unavailable
                    disabledList.innerHTML = "";
                    disabled.forEach((server) => {
                      const serverDiv = document.createElement("div");
                      serverDiv.style.cssText = "padding:0.75rem; margin-bottom:0.5rem; background:var(--state-down-bg); border:1px solid var(--error); border-radius:0.4rem; display:flex; justify-content:space-between; align-items:center;";

                      const serverInfo = document.createElement("div");
                      serverInfo.style.cssText = "flex:1;";

                      const serverName = document.createElement("div");
                      serverName.style.cssText = "font-weight:bold; color:var(--error); margin-bottom:0.25rem;";
                      serverName.textContent = server;

                      const failureCount = failures[server] || 0;
                      const failureInfo = document.createElement("div");
                      failureInfo.style.cssText = "font-size:var(--font-sm); color:var(--muted);";
                      failureInfo.textContent = `${failureCount} failure${failureCount !== 1 ? 's' : ''} recorded`;

                      serverInfo.appendChild(serverName);
                      serverInfo.appendChild(failureInfo);

                      const resetBtn = document.createElement("button");
                      resetBtn.textContent = "Reset";
                      resetBtn.className = "tag";
                      resetBtn.style.cssText = "cursor:pointer; background:var(--accent-soft); border-color:var(--accent); padding:0.3rem 0.6rem; font-size:var(--font-sm);";
                      resetBtn.onclick = async () => {
                        try {
                          const agentBase = getAgentBase();
                          const token = getAuthToken();
                          const headers = { "Content-Type": "application/json" };
                          if (token) headers["Authorization"] = "Bearer " + token;

                          const res = await fetch(`${agentBase}/admin/circuit-breaker/reset`, {
                            method: "POST",
                            headers: headers,
                            body: JSON.stringify({ server: server }),
                            credentials: "same-origin"
                          });

                          if (res.ok) {
                            console.log(`Circuit breaker reset for ${server}`);
                            refresh();
                          } else {
                            const error = await res.json().catch(() => ({ error: `HTTP ${res.status}` }));
                            console.error(`Failed to reset circuit breaker: ${error.error || res.status}`);
                          }
                        } catch (e) {
                          console.error(`Error resetting circuit breaker: ${e.message}`);
                        }
                      };

                      serverDiv.appendChild(serverInfo);
                      serverDiv.appendChild(resetBtn);
                      disabledList.appendChild(serverDiv);
                    });
                  }
                } catch (e) {
                  console.error("Failed to fetch circuit breaker details:", e);
                  disabledList.innerHTML = '<div class="muted" style="padding:0.5rem; color:var(--error);">Failed to load details</div>';
                }
              })();
            } else {
              // No disabled servers - show empty state
              disabledList.innerHTML = '<div class="muted" style="padding:0.5rem; text-align:center; color:var(--ok);">‚úì All MCP servers are healthy</div>';
            }
          }

          if (disabled.length > 0 || Object.keys(failures).length > 0) {
            let cbText = "";
            if (disabled.length > 0) {
              cbText += `‚ö† Disabled: ${disabled.join(", ")}`;
            }
            if (Object.keys(failures).length > 0) {
              const failureEntries = Object.entries(failures).filter(([_, count]) => count > 0);
              if (failureEntries.length > 0) {
                if (cbText) cbText += " ‚Ä¢ ";
                cbText += `Failures: ${failureEntries.map(([s, c]) => `${s}(${c})`).join(", ")}`;
              }
            }
            safeSetText("circuit-breaker-status", cbText);
            safeSetStyle("circuit-breaker-status", "color", CSS_VARS.WARN);
          } else {
            safeSetText("circuit-breaker-status", "‚úì All MCP servers healthy");
            safeSetStyle("circuit-breaker-status", "color", CSS_VARS.OK);
          }

          // Internet status
          if (agentRoot && agentRoot.internet) {
            const online = agentRoot.internet.available !== false; // Default to true if not explicitly false
            const lastChecked = agentRoot.internet.last_checked || 0;
            const now = Math.floor(Date.now() / 1000);
            const ageSeconds = now - lastChecked;
            safeSetText("internet-status", online ? "ONLINE" : "OFFLINE");
            const internetStatusEl = $("internet-status");
            const internetDetailsEl = $("internet-details");
            if (internetStatusEl) {
              internetStatusEl.className = CLASS_NAMES.KPI_VALUE + " " + (online ? CLASS_NAMES.KPI_VALUE_STRONG : "error-text");
              // Use consistent state color pairs
              internetStatusEl.style.color = online ? CSS_VARS.OK : CSS_VARS.ERROR;
            }
            if (internetDetailsEl) {
              if (ageSeconds < 300) { // Less than 5 minutes old
                const ageStr = ageSeconds < 60 ? `${ageSeconds}s ago` : `${Math.floor(ageSeconds / 60)}m ago`;
                internetDetailsEl.textContent = `Last checked: ${ageStr}`;
              } else {
                internetDetailsEl.textContent = `Last checked: ${Math.floor(ageSeconds / 60)}m ago`;
              }
            }
            const lastCheckedTime = new Date(agentRoot.internet.last_checked * 1000).toLocaleTimeString();
            safeSetText("internet-details", online ? `Connected (checked ${lastCheckedTime})` : `No connection (checked ${lastCheckedTime})`);
          } else {
            safeSetText("internet-status", "Unknown");
            safeSetText("internet-details", "");
          }

          // Fallback status
          const fallbackEnabled = agentRoot.fallback_enabled;
          const fallbackModel = agentRoot.fallback_model || "openai:gpt-5.2";
          safeSetText("fallback-status-text", fallbackEnabled ? "ENABLED" : "DISABLED");
          const fallbackTag = $("fallback-status-tag");
          if (fallbackTag) {
            fallbackTag.className = "tag " + (fallbackEnabled ? CLASS_NAMES.TAG_OK : CLASS_NAMES.TAG_WARN);
          }
          safeSetText("fallback-info", `Model: ${fallbackModel}`);

          // Persona switching status
          const personaSwitching = agentRoot.persona_model_switching;
          safeSetText("persona-switching-text", personaSwitching ? "ENABLED" : "DISABLED");
          const personaTag = $("persona-switching-tag");
          if (personaTag) {
            personaTag.className = "tag " + (personaSwitching ? CLASS_NAMES.TAG_OK : CLASS_NAMES.TAG_WARN);
            personaTag.title = personaSwitching
              ? "Orchestrator will automatically switch models based on active persona"
              : "Orchestrator will use your manually selected model (no automatic switching)";
          }

          // Hardware limits
          if (agentRoot.hardware_limits) {
            const hl = agentRoot.hardware_limits;
            $("hardware-limits").textContent = "ACTIVE";
            $("hardware-limits").classList.add("kpi-value-strong");
            const ctx = window.routerNumCtx || '‚Äî';
            $("hardware-details").innerHTML =
              `Context: ${ctx}<br>` +
              `Summarize: ${hl.summarize_threshold}<br>` +
              `Max Result: ${hl.max_tool_result_chars}`;
          } else {
            $("hardware-limits").textContent = "Standard";
            $("hardware-details").textContent = "";
          }

          // System mode (Idle Detection)
          if (systemStatus && systemStatus.ok) {
            const idle = systemStatus.is_idle;
            const fullThrottle = systemStatus.full_throttle;

            if (fullThrottle) {
              // Use consistent state color pairs - UNATTENDED is a warning state
              safeSetText("system-mode", "UNATTENDED");
              safeSetStyle("system-mode", "color", CSS_VARS.WARN);
              safeSetHTML("system-mode-details", "<strong>FULL THROTTLE</strong><br>No users logged in");
            } else {
              safeSetText("system-mode", idle ? "IDLE" : "ACTIVE");
              // System Mode should be green when it has a value
              safeSetStyle("system-mode", "color", CSS_VARS.OK);
              safeSetHTML("system-mode-details",
                `Load: ${systemStatus.load_percent}%<br>` +
                `Active Req: ${systemStatus.active_requests}`);
            }
          } else {
            safeSetText("system-mode", "UNKNOWN");
            safeSetStyle("system-mode", "color", CSS_VARS.MUTED);
            safeSetText("system-mode-details", "Status unavailable");
          }

          // Dashboard Health - Use consistent state color pairs
          if (routerOk && agentOk) {
            safeSetText("dashboard-health", "HEALTHY");
            safeSetStyle("dashboard-health", "color", CSS_VARS.OK);
            safeSetText("dashboard-details", "Full link established");
          } else {
            safeSetText("dashboard-health", "DEGRADED");
            safeSetStyle("dashboard-health", "color", CSS_VARS.ERROR);
            safeSetText("dashboard-details", !routerOk ? "No link to Router" : "No link to Agent");
          }


          // Model Intelligence
          if (routerRoot && routerRoot.model_intelligence) {
            const mi = routerRoot.model_intelligence;
            const html = Object.entries(mi).map(([model, data]) => `
              <div style="background: rgba(148,163,184,0.05); padding: 1rem; border-radius: 0.5rem; border: 1px solid rgba(148,163,184,0.1);">
                <div style="color:var(--accent); font-weight:bold; font-family:var(--mono); margin-bottom: 0.5rem; border-bottom: 1px solid rgba(148,163,184,0.1); padding-bottom: 0.3rem;">${model}</div>
                <div style="font-size:0.8rem; line-height: 1.5;">
                  <div style="margin-bottom: 0.4rem;"><span style="color:var(--ok); font-weight: bold;">SKILLS:</span> ${data.skills?.join(", ") || 'none'}</div>
                  <div style="margin-bottom: 0.4rem;"><span style="color:var(--error); font-weight: bold;">LIMITS:</span> ${data.weaknesses?.join(", ") || 'none'}</div>
                  <div><span style="color:var(--muted); font-style: italic;">Best for: ${data.preferred_for?.join(", ") || 'general'}</span></div>
                </div>
              </div>
            `).join("");
            $("model-skills-list").innerHTML = html || '<div class="muted">No model intelligence data.</div>';
          }

          // Persona Status - should be green when it has a value, show "none" if blank
          if (systemStatus && systemStatus.last_persona) {
            const lp = systemStatus.last_persona;
            safeSetText("last-persona", lp.name || "General");
            safeSetStyle("last-persona", "color", CSS_VARS.OK);
            safeSetText("persona-mission", lp.mission ? (lp.mission.substring(0, 45) + "...") : "");
          } else {
            safeSetText("last-persona", "none");
            safeSetStyle("last-persona", "color", CSS_VARS.MUTED);
            safeSetText("persona-mission", "No persona active");
          }
        } else {
          const agentOkEl = $("agent-ok");
          if (agentOkEl) {
            agentOkEl.textContent = "DOWN";
            agentOkEl.classList.remove("kpi-value-strong");
          }
          const agentModelEl = $("agent-model");
          if (agentModelEl) agentModelEl.textContent = "";
          const mcpBadgesEl = $("mcp-badges");
          if (mcpBadgesEl) mcpBadgesEl.innerHTML = "";
          // Show start button, hide stop button
          const startAgentBtn = $("start-agent-btn");
          if (startAgentBtn) startAgentBtn.style.display = "inline-flex";
          const stopAgentBtn = $("stop-agent-btn");
          if (stopAgentBtn) stopAgentBtn.style.display = "none";
          // Show restart buttons (router and all can restart even if agent is down)
          const restartRouterBtn = $("restart-router-btn");
          if (restartRouterBtn) restartRouterBtn.style.display = "inline-flex";
          const restartAllBtn = $("restart-all-btn");
          if (restartAllBtn) restartAllBtn.style.display = "inline-flex";
          const restartAgentBtn = $("restart-agent-btn");
          if (restartAgentBtn) restartAgentBtn.style.display = "none";
          // Clear active LLM if agent is down
          const activeLLMEl = $("active-llm");
          if (activeLLMEl) {
            activeLLMEl.textContent = "‚Äî";
            activeLLMEl.classList.remove("kpi-value-strong");
          }
          const activeLLMDetailsEl = $("active-llm-details");
          if (activeLLMDetailsEl) activeLLMDetailsEl.textContent = "";
          const circuitBreakerStatusEl = $("circuit-breaker-status");
          if (circuitBreakerStatusEl) circuitBreakerStatusEl.textContent = "‚Äî";
          const internetStatusEl = $("internet-status");
          if (internetStatusEl) internetStatusEl.textContent = "‚Äî";
          const internetDetailsEl = $("internet-details");
          if (internetDetailsEl) internetDetailsEl.textContent = "";
        }

        // Tool Usage Analytics (for Tools & MCP tab)
        if (agentMetrics && agentMetrics.ok && agentMetrics.tool_metrics) {
          const tm = agentMetrics.tool_metrics;
          const byTool = tm.by_tool || {};
          const byMCP = tm.by_mcp_server || {};

          // Top 5 tools by usage
          const toolEntries = Object.entries(byTool)
            .sort((a, b) => (b[1].calls || 0) - (a[1].calls || 0))
            .slice(0, 5);
          if (toolEntries.length > 0) {
            safeSetHTML("tool-usage-breakdown", "<strong>Top Tools:</strong><br>" + toolEntries.map(([tool, stats]) => {
              const successRate = stats.calls > 0 ? ((stats.successes / stats.calls) * 100).toFixed(0) : "0";
              return `${tool}: ${stats.calls} calls (${successRate}% success) ‚Ä¢ avg ${(stats.avg_time_ms || 0).toFixed(0)}ms`;
            }).join("<br>"));
          } else {
            safeSetText("tool-usage-breakdown", "No tool usage data yet.");
          }

          // Render tool performance chart
          renderToolPerformanceChart(tm);
        } else {
          safeSetText("tool-usage-breakdown", "‚Äî");
        }

        // Store activity data and render charts
        if (metrics && metrics.ok) {
          try {
            rawActivityData = metrics.recent_requests || [];
            renderActivity(rawActivityData);
            renderModelPerformanceChart(metrics);
          } catch (e) {
            console.error("Error rendering activity:", e);
            rawActivityData = [];
            renderActivity([]);
          }
        } else {
          rawActivityData = [];
          renderActivity([]);
        }

        // Alerts
        if (agentMetrics && agentMetrics.ok && agentMetrics.alerts && agentMetrics.alerts.length > 0) {
          const alertsHtml = agentMetrics.alerts.slice().reverse().map(alert => {
            const time = new Date(alert.timestamp * 1000).toLocaleTimeString();
            const type = alert.type || "unknown";
            let color = "var(--warn)";
            let icon = "‚ö†";
            if (type.includes("circuit_breaker") || type.includes("failure")) {
              color = "var(--error)";
              icon = "‚úó";
            }
            let details = "";
            if (alert.tool) details += ` Tool: ${alert.tool}`;
            if (alert.server) details += ` Server: ${alert.server}`;
            if (alert.elapsed_ms) details += ` Time: ${alert.elapsed_ms.toFixed(0)}ms`;
            if (alert.factor) details += ` (${alert.factor.toFixed(1)}x slower)`;
            return `<div style="margin-bottom:0.3rem; color:${color};">${icon} <span style="color:var(--text);">${time}</span> <strong>${type}</strong><span style="color:var(--muted);">${details}</span></div>`;
          }).join("");
          $("alerts-list").innerHTML = alertsHtml;
        } else {
          $("alerts-list").innerHTML = '<div class="muted">No alerts.</div>';
        }

        // Model configuration moved to Model Services tab - no longer displayed in Overview

        // Active LLM logic moved to Model Services tab - no longer displayed in Overview

        // Costs / Usage
        if (metrics && metrics.ok && metrics.usage && metrics.usage.total) {
          const t = metrics.usage.total;
          const req = t.requests || 0;
          const pt = t.prompt_tokens || 0;
          const ct = t.completion_tokens || 0;
          const tt = t.total_tokens || (pt + ct);
          const cost = t.cost_usd || 0.0;
          const costStr = cost > 0 ? ` ‚Ä¢ Cost: $${cost.toFixed(4)}` : "";
          const costsSummaryEl = $("costs-summary");
          if (costsSummaryEl) {
            costsSummaryEl.textContent = `Requests: ${req} ‚Ä¢ Prompt tokens: ${pt} ‚Ä¢ Completion tokens: ${ct} ‚Ä¢ Total tokens: ${tt}${costStr} (resets on restart)`;
          }

          // Recent Activity
          const recent = metrics.recent_requests || [];
          if (recent.length > 0) {
            const activityHtml = recent.slice().reverse().map(r => {
              const time = new Date(r.timestamp * 1000).toLocaleTimeString();
              const status = r.success ? "‚úì" : "‚úó";
              const statusColor = r.success ? "var(--ok)" : "var(--error)";
              const model = r.model_full || `${r.provider}:${r.model}`;
              const tokens = r.tokens ? ` ‚Ä¢ ${r.tokens} tokens` : "";
              const cost = r.cost_usd || 0.0;
              const costStr = cost > 0 ? ` ‚Ä¢ $${cost.toFixed(4)}` : "";
              return `<div style="margin-bottom:0.3rem; color:${statusColor};">${status} <span style="color:var(--text);">${time}</span> ${model} <span style="color:var(--muted);">${r.elapsed_ms}ms${tokens}${costStr}</span></div>`;
            }).join("");
            // Activity is now rendered by renderActivity() function
          } else {
            rawActivityData = [];
            renderActivity([]);
          }

          // Model Usage Breakdown
          const byModel = metrics.usage.by_model || {};
          const modelEntries = Object.entries(byModel)
            .sort((a, b) => (b[1].requests || 0) - (a[1].requests || 0))
            .slice(0, 5);
          const modelUsageEl = $("model-usage");
          if (modelUsageEl) {
            if (modelEntries.length > 0) {
              modelUsageEl.innerHTML = modelEntries.map(([model, stats]) => {
                const cost = stats.cost_usd || 0.0;
                const costStr = cost > 0 ? ` ‚Ä¢ $${cost.toFixed(4)}` : "";
                return `${model}: ${stats.requests} req ‚Ä¢ ${stats.total_tokens || 0} tokens${costStr}`;
              }).join("<br>");
            } else {
              modelUsageEl.textContent = "No model usage data yet.";
            }
          }

          // Performance Stats - Enhanced
          if (recent.length > 0) {
            const successful = recent.filter(r => r.success).length;
            const failed = recent.length - successful;
            const avgTime = recent.reduce((sum, r) => sum + (r.elapsed_ms || 0), 0) / recent.length;
            const minTime = Math.min(...recent.map(r => r.elapsed_ms || 0));
            const maxTime = Math.max(...recent.map(r => r.elapsed_ms || 0));
            const successRate = ((successful / recent.length) * 100).toFixed(1);
            const totalTokens = recent.reduce((sum, r) => sum + (r.tokens || 0), 0);
            const totalCost = recent.reduce((sum, r) => sum + (r.cost_usd || 0), 0);
            const costStr = totalCost > 0 ? ` ‚Ä¢ Cost: $${totalCost.toFixed(4)}` : '';
            const perfStatsEl = $("performance-stats");
            if (perfStatsEl) {
              perfStatsEl.innerHTML =
                `<strong>Success Rate:</strong> ${successRate}% (${successful}‚úì / ${failed}‚úó) ‚Ä¢ ` +
                `<strong>Response Time:</strong> ${avgTime.toFixed(0)}ms avg (${minTime.toFixed(0)}-${maxTime.toFixed(0)}ms) ‚Ä¢ ` +
                `<strong>Total:</strong> ${recent.length} requests ‚Ä¢ ${totalTokens} tokens${costStr}`;
            }
          } else {
            const perfStatsEl = $("performance-stats");
            if (perfStatsEl) {
              perfStatsEl.textContent = "No performance data yet (waiting for requests).";
            }
          }
        } else {
          const costsSummaryEl = $("costs-summary");
          if (costsSummaryEl) {
            costsSummaryEl.textContent = "No usage metrics yet (they populate after chat requests).";
          }
          rawActivityData = [];
          renderActivity([]);
          const modelUsageEl = $("model-usage");
          if (modelUsageEl) {
            modelUsageEl.textContent = "‚Äî";
          }
          const perfStatsEl = $("performance-stats");
          if (perfStatsEl) {
            perfStatsEl.textContent = "‚Äî";
          }
        }

        // Background Tasks - fetch separately
        try {
          const bgTasksRes = await fetchJson(agentBase + "/admin/background-tasks", headers).catch(() => null);
          if (bgTasksRes && bgTasksRes.ok && bgTasksRes.tasks) {
            const tasks = bgTasksRes.tasks;
            const now = Math.floor(Date.now() / 1000);
            const tasksHtml = Object.entries(tasks).map(([name, info]) => {
              try {
                if (!info || typeof info !== 'object') return '';
                const statusColor = info.enabled ? (info.last_error ? "var(--error)" : "var(--ok)") : "var(--muted)";
                const idleTag = info.idle_only ? ' <span class="tag" style="font-size:0.6rem; padding:0.1rem 0.3rem;">IDLE-ONLY</span>' : '';
                const scheduleTag = info.schedule ? ` <span class="tag" style="font-size:0.6rem; padding:0.1rem 0.3rem; background:rgba(79,139,255,0.15); border-color:var(--accent); color:var(--accent);">${info.schedule}</span>` : '';
                const nextRun = info.next_run ? ` ‚Ä¢ Next: ${new Date(info.next_run * 1000).toLocaleTimeString()}` : '';
                const isPending = info.enabled && !info.last_error && info.next_run && info.next_run > now;
                const isActive = info.enabled && !info.last_error && (!info.next_run || info.next_run <= now);
                const statusText = info.enabled
                  ? (info.last_error ? "ERROR" : (isPending ? "PENDING" : (isActive ? "ACTIVE" : "READY")))
                  : "DISABLED";
                const runCount = info.run_count || 0;
                const lastRun = info.last_run ? new Date(info.last_run * 1000).toLocaleString() : 'never';
                const lastError = (info.last_error || '').toString().replace(/['"]/g, '');
                return `
                  <div style="margin-bottom:0.75rem; padding:0.5rem; border-radius:0.4rem; background:${isPending ? 'rgba(250,204,21,0.08)' : (isActive ? 'rgba(74,222,128,0.08)' : 'rgba(15,23,42,0.5)')}; border:1px solid ${isPending ? 'rgba(250,204,21,0.2)' : (isActive ? 'rgba(74,222,128,0.2)' : 'rgba(148,163,184,0.1)')};">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.3rem;">
                      <div>
                        <strong style="color:var(--text);">${name}</strong>${idleTag}${scheduleTag}
                      </div>
                      <div style="display:flex; align-items:center; gap:0.5rem;">
                        <span style="color:${statusColor}; font-size:0.7rem; font-weight:bold;">${statusText}</span>
                        ${info.enabled
                    ? `<button onclick="toggleBackgroundTask('${name}', false)" class="tag" style="cursor:pointer; background:rgba(255,107,129,0.1); border-color:var(--error); color:var(--error); padding:0.1rem 0.4rem; font-size:0.65rem;">Disable</button>`
                    : `<button onclick="toggleBackgroundTask('${name}', true)" class="tag" style="cursor:pointer; background:rgba(74,222,128,0.1); border-color:var(--ok); color:var(--ok); padding:0.1rem 0.4rem; font-size:0.65rem;">Enable</button>`
                  }
                      </div>
                    </div>
                    <div style="font-size:0.75rem; color:var(--muted);">
                      Runs: ${runCount} ‚Ä¢ Last: ${lastRun}${nextRun}
                    </div>
                    ${lastError ? `<div style="font-size:0.7rem; color:var(--error); margin-top:0.3rem;">Error: ${lastError}</div>` : ''}
                  </div>
                `;
              } catch (e) {
                console.warn("Error rendering background task:", e, name, info);
                return '';
              }
            }).filter(h => h).join("");
            const bgTasksEl = $("background-tasks-list");
            if (bgTasksEl) bgTasksEl.innerHTML = tasksHtml || '<div class="muted">No background tasks configured.</div>';
          } else {
            const bgTasksEl = $("background-tasks-list");
            if (bgTasksEl) bgTasksEl.innerHTML = '<div class="muted">' + (bgTasksRes?.message || 'No background tasks data available.') + '</div>';
          }
        } catch (e) {
          console.error("Error loading background tasks:", e);
          const bgTasksEl = $("background-tasks-list");
          if (bgTasksEl) bgTasksEl.innerHTML = '<div class="muted">Error loading background tasks: ' + (e.message || "Unknown error") + '</div>';
        }

        setStatus(routerOk, agentOk);
      } catch (err) {
        console.error(err);
        safeSetHTML("recent-activity", '<div class="muted">Error loading activity.</div>');
        safeSetText("model-usage", "Error loading data.");
        setStatus(false, false);
        // Track refresh error with duration (only if refreshStartTime is defined)
        if (typeof refreshStartTime !== 'undefined') {
          const refreshDuration = performance.now() - refreshStartTime;
          trackError(err, "refresh", { duration_ms: refreshDuration });
        } else {
          trackError(err, "refresh", {});
        }
      } finally {
        const refreshBtn = $("refresh-btn");
        if (refreshBtn) refreshBtn.disabled = false;
        // Track refresh completion with duration (only if refreshStartTime is defined)
        if (typeof refreshStartTime !== 'undefined') {
          const refreshDuration = performance.now() - refreshStartTime;
          trackInteraction("refresh", "dashboard", true, refreshDuration, {
            router_ok: routerOk,
            agent_ok: agentOk
          });
        }
      }
    }

    // Update MCP toggle UI based on current state
    function updateMCPToggleUI() {
      const statusEl = $("mcp-toggle-status");
      const detailsEl = $("mcp-toggle-details");
      if (statusEl) {
        statusEl.textContent = mcpToolAccessEnabled ? "Enabled" : "Disabled";
        statusEl.style.color = mcpToolAccessEnabled ? "var(--ok)" : "var(--muted)";
      }
      if (detailsEl) {
        detailsEl.textContent = mcpToolAccessEnabled
          ? "Routing through agent-runner with tools"
          : "Direct model access (no tools)";
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      // Debug: Log that DOMContentLoaded fired
      console.log("Dashboard: DOMContentLoaded fired");

      // Initialize router base URL from localStorage or default
      const routerBaseEl = $("router-base");
      if (routerBaseEl) {
        const currentHost = window.location.hostname;
        const savedBase = localStorage.getItem("router_base_url");
        if (savedBase) {
          // Check if saved base matches current origin to avoid CORS issues
          const savedUrl = new URL(savedBase);
          const savedHost = savedUrl.hostname;
          // If hostname mismatch (localhost vs 127.0.0.1), use current hostname
          if (savedHost !== currentHost && (savedHost === "127.0.0.1" || savedHost === "localhost")) {
            const correctedBase = savedBase.replace(savedHost, currentHost);
            routerBaseEl.value = correctedBase;
            localStorage.setItem("router_base_url", correctedBase);
            console.log("Dashboard: Corrected router base to match current origin:", correctedBase);
          } else {
            routerBaseEl.value = savedBase;
            console.log("Dashboard: Loaded router base from localStorage:", savedBase);
          }
        } else if (!routerBaseEl.value.trim()) {
          // Default to match current origin to avoid CORS issues
          const defaultBase = `http://${currentHost}:5455`;
          routerBaseEl.value = defaultBase;
          localStorage.setItem("router_base_url", defaultBase);
          console.log("Dashboard: Set default router base:", defaultBase);
        }
      } else {
        console.error("Dashboard: router-base element not found!");
      }

      // Initialize manually set Active LLM from localStorage on page load
      // (variable is already declared at module scope, just load the value)
      manuallySetActiveLLM = localStorage.getItem("manuallySetActiveLLM") || null;
      manuallySetAgentModel = localStorage.getItem("manuallySetAgentModel") || null;

      // Initialize debug mode toggle
      const debugToggle = $("debug-mode-toggle");
      if (debugToggle) {
        debugToggle.checked = debugMode;
        toggleDebugMode(); // Apply initial state
      }

      // Initialize MCP toggle UI - load from router API
      const mcpToggle = $("mcp-toggle");
      if (mcpToggle) {
        // Load initial state from router (will be updated on first refresh)
        mcpToggle.addEventListener("change", async (e) => {
          const enabled = e.target.checked;
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          const token = $("auth-token").value.trim();
          const headers = { "Content-Type": "application/json", "Accept": "application/json" };
          if (token) headers["Authorization"] = "Bearer " + token;

          try {
            const result = await postJson(base + "/admin/mcp-toggle", headers, { enabled });
            mcpToolAccessEnabled = result.mcp_tool_access_enabled;
            updateMCPToggleUI();

            // When enabling MCP toggle, sync router's active_model to agent-runner
            if (enabled && manuallySetActiveLLM) {
              const agentBase = base.includes(":5455") ? base.replace(":5455", ":5460") : base.replace(/\/+$/, "") + ":5460";
              try {
                await postJson(agentBase + "/admin/set-model", { "Content-Type": "application/json" }, { model: manuallySetActiveLLM });
              } catch (e) {
                console.warn("Failed to sync agent-runner model when enabling MCP:", e);
              }
            }

            refresh();
          } catch (e) {
            alert(`‚úó Failed to update MCP toggle: ${e.message}`);
            // Revert checkbox
            mcpToggle.checked = mcpToolAccessEnabled;
          }
        });
      }

      // Auto-detect router base URL from current page location
      const routerBaseInput = $("router-base");
      if (!routerBaseInput.value) {
        // If served from /dashboard, use same origin; otherwise default to localhost
        const origin = window.location.origin;
        if (origin && origin !== "null") {
          routerBaseInput.value = origin;
        } else {
          routerBaseInput.value = "http://127.0.0.1:5455";
        }
      }

      // Save auth token button
      const saveAuthTokenBtn = $("save-auth-token-btn");
      if (saveAuthTokenBtn) {
        saveAuthTokenBtn.addEventListener("click", async () => {
          const token = $("auth-token").value.trim();
          if (!token) {
            alert("Please enter an auth token first");
            return;
          }

          const confirmed = confirm(
            "This will update the auth token in config.yaml and restart the router.\n\n" +
            "You will need to re-enter the token after restart.\n\n" +
            "Continue?"
          );

          if (!confirmed) return;

          const base = getRouterBase();
          const currentToken = getAuthToken();
          const headers = getHeaders(currentToken);

          try {
            saveAuthTokenBtn.disabled = true;
            saveAuthTokenBtn.textContent = "Saving...";

            const result = await postJson(
              base + "/admin/auth-token",
              headers,
              { auth_token: token, restart: true }
            );

            if (result && result.ok) {
              alert(`‚úì ${result.message || "Auth token saved successfully"}\n\nRouter restart initiated.`);
              // Clear the field since router will restart
              $("auth-token").value = "";
              localStorage.removeItem("router_auth_token");
            } else {
              alert("Failed to save auth token: " + (result?.message || "Unknown error"));
            }
          } catch (e) {
            console.error("Failed to save auth token:", e);
            alert("Error saving auth token: " + (e.message || "Unknown error"));
          } finally {
            saveAuthTokenBtn.disabled = false;
            saveAuthTokenBtn.textContent = "Save Token";
          }
        });
      }

      const refreshBtn = $("refresh-btn");
      if (refreshBtn) {
        refreshBtn.addEventListener("click", () => {
          refresh();
        });
      }

      // show-all-models-check element was removed from Models tab
      const showAllCheck = $("show-all-models-check");
      if (showAllCheck) {
        showAllCheck.addEventListener("change", () => {
          refresh();
        });
      }

      const reloadBtn = $("reload-btn");
      if (reloadBtn) {
        reloadBtn.addEventListener("click", async () => {
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          const token = $("auth-token").value.trim();
          const headers = { "Content-Type": "application/json", "Accept": "application/json" };
          if (token) headers["Authorization"] = "Bearer " + token;
          const statusText = $("status-text");
          if (statusText) statusText.textContent = "Reloading providers‚Ä¶";
          try {
            await postJson(base + "/admin/reload", headers, {});
          } catch (e) {
            console.error(e);
          }
          refresh();
        });
      }

      const clearCacheBtn = $("clear-cache-btn");
      if (clearCacheBtn) {
        clearCacheBtn.addEventListener("click", async () => {
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          const token = $("auth-token").value.trim();
          const headers = { "Content-Type": "application/json", "Accept": "application/json" };
          if (token) headers["Authorization"] = "Bearer " + token;
          const statusText = $("status-text");
          if (statusText) statusText.textContent = "Clearing cache‚Ä¶";
          try {
            await postJson(base + "/admin/cache/clear", headers, {});
          } catch (e) {
            console.error(e);
          }
          refresh();
        });
      }


      const startAgentBtn = $("start-agent-btn");
      if (startAgentBtn) {
        startAgentBtn.addEventListener("click", async () => {
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          const token = $("auth-token").value.trim();
          const headers = { "Content-Type": "application/json", "Accept": "application/json" };
          if (token) headers["Authorization"] = "Bearer " + token;
          const statusText = $("status-text");
          if (statusText) statusText.textContent = "Starting agent-runner‚Ä¶";
          startAgentBtn.disabled = true;
          try {
            await postJson(base + "/admin/start-agent", headers, {});
            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait for service to start
          } catch (e) {
            console.error(e);
          } finally {
            startAgentBtn.disabled = false;
          }
          refresh();
        });
      }

      const stopAgentBtn = $("stop-agent-btn");
      if (stopAgentBtn) {
        stopAgentBtn.addEventListener("click", async () => {
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          const token = $("auth-token").value.trim();
          const headers = { "Content-Type": "application/json", "Accept": "application/json" };
          if (token) headers["Authorization"] = "Bearer " + token;
          const statusText = $("status-text");
          if (statusText) statusText.textContent = "Stopping agent-runner‚Ä¶";
          stopAgentBtn.disabled = true;
          try {
            await postJson(base + "/admin/stop-agent", headers, {});
          } catch (e) {
            console.error(e);
          } finally {
            stopAgentBtn.disabled = false;
          }
          refresh();
        });
      }

      const restartAgentBtn = $("restart-agent-btn");
      if (restartAgentBtn) {
        restartAgentBtn.addEventListener("click", async () => {
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          const token = $("auth-token").value.trim();
          const headers = { "Content-Type": "application/json", "Accept": "application/json" };
          if (token) headers["Authorization"] = "Bearer " + token;
          if (!confirm("Restart agent-runner? This will temporarily interrupt agent operations.")) return;
          const statusText = $("status-text");
          if (statusText) statusText.textContent = "Restarting agent-runner‚Ä¶";
          restartAgentBtn.disabled = true;
          try {
            await postJson(base + "/admin/restart-agent", headers, {});
            await new Promise(resolve => setTimeout(resolve, 3000)); // Wait for restart
          } catch (e) {
            console.error(e);
          } finally {
            restartAgentBtn.disabled = false;
          }
          refresh();
        });
      }

      const restartRouterBtn = $("restart-router-btn");
      if (restartRouterBtn) {
        restartRouterBtn.addEventListener("click", async () => {
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          const token = $("auth-token").value.trim();
          const headers = { "Content-Type": "application/json", "Accept": "application/json" };
          if (token) headers["Authorization"] = "Bearer " + token;
          // Restart router (no confirmation needed)
          const statusText = $("status-text");
          if (statusText) statusText.textContent = "Restarting router‚Ä¶";
          restartRouterBtn.disabled = true;
          try {
            await postJson(base + "/admin/restart-router", headers, {});
            await new Promise(resolve => setTimeout(resolve, 3000)); // Wait for restart
          } catch (e) {
            console.error(e);
          } finally {
            restartRouterBtn.disabled = false;
          }
          refresh();
        });
      }

      const restartAllBtn = $("restart-all-btn");
      if (restartAllBtn) {
        restartAllBtn.addEventListener("click", async () => {
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          const token = $("auth-token").value.trim();
          const headers = { "Content-Type": "application/json", "Accept": "application/json" };
          if (token) headers["Authorization"] = "Bearer " + token;
          if (!confirm("Restart ALL services (router, agent-runner, surrealdb)? This will interrupt all operations.")) return;
          const statusText = $("status-text");
          if (statusText) statusText.textContent = "Restarting all services‚Ä¶";
          restartAllBtn.disabled = true;
          try {
            await postJson(base + "/admin/restart-all", headers, {});
            await new Promise(resolve => setTimeout(resolve, 5000)); // Wait for restart
          } catch (e) {
            console.error(e);
          } finally {
            restartAllBtn.disabled = false;
          }
          refresh();
        });
      }


      const editFileBtn = $("edit-file-btn");
      const fileSelector = $("file-selector");
      if (editFileBtn && fileSelector) {
        editFileBtn.addEventListener("click", () => {
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          let agentBase = base.includes(":5455") ? base.replace(":5455", ":5460") : base.replace(/\/+$/, "") + ":5460";
          const token = getAuthToken();
          const selectedFile = fileSelector.value;
          const params = new URLSearchParams();
          params.set("base", agentBase);
          if (token) params.set("token", token);
          params.set("file", selectedFile);
          window.open(`${agentBase}/editor?${params.toString()}`, "_blank");
        });
      }

      // Search/filter event listeners
      const activitySearch = $("activity-search");
      const activityFilter = $("activity-filter");
      if (activitySearch) {
        activitySearch.addEventListener("input", filterActivity);
        activitySearch.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            activitySearch.value = "";
            filterActivity();
          }
        });
      }
      if (activityFilter) {
        activityFilter.addEventListener("change", filterActivity);
      }

      const memorySearch = $("memory-search");
      const memoryFilter = $("memory-filter");
      if (memorySearch) {
        memorySearch.addEventListener("input", filterMemoryFacts);
        memorySearch.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            memorySearch.value = "";
            filterMemoryFacts();
          }
        });
      }
      if (memoryFilter) {
        memoryFilter.addEventListener("change", filterMemoryFacts);
      }

      const manualSearch = $("manual-search");
      if (manualSearch) {
        manualSearch.addEventListener("input", filterManual);
        manualSearch.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            manualSearch.value = "";
            filterManual();
          }
        });
      }

      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        // Ctrl/Cmd + K: Focus search in current tab
        if ((e.ctrlKey || e.metaKey) && e.key === "k") {
          e.preventDefault();
          const activeTab = document.querySelector(".tab-content.active");
          if (activeTab) {
            const tabId = activeTab.id;
            if (tabId === "activity" && activitySearch) {
              activitySearch.focus();
            } else if (tabId === "memory" && memorySearch) {
              memorySearch.focus();
            } else if (tabId === "documentation" && manualSearch) {
              manualSearch.focus();
            }
          }
        }
        // Ctrl/Cmd + R: Refresh (prevent default browser refresh)
        if ((e.ctrlKey || e.metaKey) && e.key === "r" && !e.shiftKey) {
          e.preventDefault();
          refresh();
        }
        // Escape: Clear search and blur
        if (e.key === "Escape" && document.activeElement && document.activeElement.tagName === "INPUT") {
          const input = document.activeElement;
          if (input.value) {
            input.value = "";
            if (input.id === "activity-search") filterActivity();
            else if (input.id === "memory-search") filterMemoryFacts();
            else if (input.id === "manual-search") filterManual();
          }
          input.blur();
        }
      });


      const enableFallbackBtn = $("enable-fallback-btn");
      if (enableFallbackBtn) {
        enableFallbackBtn.addEventListener("click", async () => {
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          const agentBase = base.includes(":5455") ? base.replace(":5455", ":5460") : base.replace(/\/+$/, "") + ":5460";
          try {
            await postJson(agentBase + "/admin/fallback/toggle", { "Content-Type": "application/json" }, { enabled: true });
            refresh();
          } catch (e) {
            console.error(e);
          }
        });
      }

      const disableFallbackBtn = $("disable-fallback-btn");
      if (disableFallbackBtn) {
        disableFallbackBtn.addEventListener("click", async () => {
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          const agentBase = base.includes(":5455") ? base.replace(":5455", ":5460") : base.replace(/\/+$/, "") + ":5460";
          try {
            await postJson(agentBase + "/admin/fallback/toggle", { "Content-Type": "application/json" }, { enabled: false });
            refresh();
          } catch (e) {
            console.error(e);
          }
        });
      }

      const enablePersonaSwitchingBtn = $("enable-persona-switching-btn");
      if (enablePersonaSwitchingBtn) {
        enablePersonaSwitchingBtn.addEventListener("click", async () => {
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          const agentBase = base.includes(":5455") ? base.replace(":5455", ":5460") : base.replace(/\/+$/, "") + ":5460";
          try {
            await postJson(agentBase + "/admin/persona-switching/toggle", { "Content-Type": "application/json" }, { enabled: true });
            refresh();
          } catch (e) {
            console.error(e);
          }
        });
      }

      const disablePersonaSwitchingBtn = $("disable-persona-switching-btn");
      if (disablePersonaSwitchingBtn) {
        disablePersonaSwitchingBtn.addEventListener("click", async () => {
          const base = $("router-base").value.trim().replace(/\/+$/, "");
          const agentBase = base.includes(":5455") ? base.replace(":5455", ":5460") : base.replace(/\/+$/, "") + ":5460";
          try {
            await postJson(agentBase + "/admin/persona-switching/toggle", { "Content-Type": "application/json" }, { enabled: false });
            refresh();
          } catch (e) {
            console.error(e);
          }
        });
      }

      // Active LLM selector moved to Model Services tab - removed from Overview
      // changeAgentModel function removed - model configuration moved to Model Services tab
      // Use changeServiceModel('agent', modelId) instead

      // Add function to clear manual Active LLM setting (optional - can be called to reset)
      function clearManualActiveLLM() {
        manuallySetActiveLLM = null;
        localStorage.removeItem("manuallySetActiveLLM");
        refresh(); // Refresh to show actual metrics-based value
      }

      // Also check database status on initial load
      updateDatabaseStatus();
      updateTaskServerStatus();

      // Model configuration moved to Model Services tab - event listeners removed

      // Load saved auth token from localStorage BEFORE first refresh
      const savedToken = localStorage.getItem("router_auth_token");
      const authTokenInput = $("auth-token");
      if (authTokenInput) {
        if (savedToken && !authTokenInput.value.trim()) {
          authTokenInput.value = savedToken;
        }

        // Save token to localStorage when user types in the field
        authTokenInput.addEventListener("input", function () {
          if (this.value.trim()) {
            localStorage.setItem("router_auth_token", this.value.trim());
            // Hide warning when token is entered
            const warningEl = $("auth-token-warning");
            if (warningEl) {
              warningEl.style.display = "none";
            }
          }
        });
      }

      // Initial load (token should now be loaded)
      console.log("Dashboard: Starting initial refresh");
      try {
        // Ensure overview tab is visible first
        showTab('overview');
        refresh();
        console.log("Dashboard: Initial refresh completed");
      } catch (e) {
        console.error("Dashboard: Error during initial refresh:", e);
        alert("Dashboard initialization error: " + e.message);
      }

      // Auto-refresh every 10 seconds (only if not suspended)
      refreshIntervalId = setInterval(() => {
        if (!refreshSuspended) {
          refresh();
        }
      }, 10000);

      // Check database status on initial load and periodically
      updateDatabaseStatus();
      updateTaskServerStatus();
      setInterval(updateDatabaseStatus, 30000); // Check every 30 seconds
    });
  </script>
</body>

</html>